<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/04/23/hello-world/"/>
      <url>/2018/04/23/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>浅谈对hashmap的理解!</title>
      <link href="/2017/09/07/hashMap%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6-1/"/>
      <url>/2017/09/07/hashMap%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6-1/</url>
      <content type="html"><![CDATA[<h4 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h4><ul><li>数据结构中有数组和链表来实现对数据的存储，但这两者基本上是两个极端。所有的数据结构都可以用这两个基本结构来构造的</li><li><strong>数组</strong>：数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；</li><li><strong>链表</strong>：链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。</li><li><strong>哈希表</strong>（(Hash table）：由数组+链表组成的。既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。实际上hashMap是一个链表散列</li></ul><hr><h4 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h4><ul><li>hashMap是一个用于存储key-value键值对的集合，每一个键值对也被叫做Entry。这些个键值对分散存储在一个数组当中，这个数组就是HaspMap的主干。</li><li>总体上看，Hashmap分为很多个数组，每一个数组里面存放着一个链表，结构图如下。</li></ul><h5 id="数据结构图形表示："><a href="#数据结构图形表示：" class="headerlink" title="数据结构图形表示："></a>数据结构图形表示：</h5><ul><li>HashMap的<strong>数组</strong>每一个元素的初始值都是Null。<blockquote><p><img src="http://upload-images.jianshu.io/upload_images/6284737-955ed6f84da5404c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote></li><li>详细的结构<blockquote><p><img src="http://upload-images.jianshu.io/upload_images/6284737-ee3a40ebee689321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><h4 id="put方法的原理："><a href="#put方法的原理：" class="headerlink" title="put方法的原理："></a>put方法的原理：</h4></li><li><p>比如调用hashMap.put(“apple”,0),插入一个key为”apple”的元素。这时候我们需要利用一个哈希函数来确定Entry的插入位置(index)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = Hash(&quot;apple&quot;)</span><br></pre></td></tr></table></figure></li><li><p>假定最后计算的index为2，那么结果如下：</p><blockquote><p><img src="http://upload-images.jianshu.io/upload_images/6284737-45f5586d614337ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>但是，因为HashMap的长度是有限的，当插入的Entry越来越多的时候，会出现index冲突的情况，比如两个值计算的index都是2，这个时候就可以利用链表来解决了<br><img src="http://upload-images.jianshu.io/upload_images/6284737-5e5613ceffe569da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>HashMap 数组的每一个元素不止包含一个Entry(键值对)对象，也包含一个链表的头结点，每一个Entry对象通过next指针指向它的下一个Entry节点(链表)，当新来的Entry映射到冲突的数组位置时，只需要插入到对应的链表即可：<br><img src="http://upload-images.jianshu.io/upload_images/6284737-84acbc1cd3522e17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>需要注意的是，新来的Entry节点插入链表时，使用的是”头插法”，这样是因为HashMap的发明者认为后插入的Entry被查找的可能性更大</li></ul></blockquote></li></ul><h4 id="Get方法的原理"><a href="#Get方法的原理" class="headerlink" title="Get方法的原理"></a>Get方法的原理</h4><ul><li><p>首先会根据输入的Key做一次Hash映射，得到对应的index：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = Hash(&quot;apple&quot;)</span><br></pre></td></tr></table></figure></li><li><p>由于刚才说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候需要顺着对应链表的头节点，一个一个向下来查找(链表)</p><blockquote><p><img src="http://upload-images.jianshu.io/upload_images/6284737-ad7cd5d1e3d73adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote></li><li>第一步，我们查看的是头节点Entry6，它的key是 banana很明显不是。</li><li>第二部，我们查看的next几点Entry1，它的key是 apple，正是结果。</li></ul><h4 id="HashMap的默认长度是16，以后每次必须是2的幂"><a href="#HashMap的默认长度是16，以后每次必须是2的幂" class="headerlink" title="HashMap的默认长度是16，以后每次必须是2的幂"></a>HashMap的默认长度是16，以后每次必须是2的幂</h4><ul><li><p>key映射到HashMap数组的对应位置，会用到一个Hash函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = Hash(&quot;apple&quot;)</span><br></pre></td></tr></table></figure></li><li><p>为了实现高效的Hash算法，HashMap的发明者采用了位运算的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = HashCode(key)&amp;(Length-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>下面演示下以”book”为例的整个过程：</p></li></ul><ol><li>计算book的hashcode，结果为十进制的3029737，二进制是10111000111010111101001.</li><li>假定默认长度是16，Length-1是15，二进制就是1111</li><li>根据公式，做与运算，结果是1001，十进制就是9.</li><li>假定默认长度是10，Lnegth-1是9，二进制就是1001</li><li>根据公式，结果也是1001，十进制是9，换一个HashCode，比如是1011100011101011101111，计算结果依然是1001<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5></li></ol><ul><li>当hashMap长度不为16的2的幂时候，出现冲突的几率会更大一些，甚至有些结果永远不会出现。</li><li>可以说，Hash算法最终得到的index结果，完全取决于key的HashCode值的最后几位。1111或者11111或者111111…都是16的2的幂，是为了保证算法均匀。</li></ul><h4 id="HashMap在高并发情况下如何处理？（后续跟进）"><a href="#HashMap在高并发情况下如何处理？（后续跟进）" class="headerlink" title="HashMap在高并发情况下如何处理？（后续跟进）"></a>HashMap在高并发情况下如何处理？（后续跟进）</h4>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
