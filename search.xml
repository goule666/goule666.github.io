<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>2019学习计划</title>
      <link href="/2019/02/13/2019%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
      <url>/2019/02/13/2019%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      <content type="html"><![CDATA[<p>​    2018学习总结，记忆较为深刻的学习有：1. hashmap原理，2. 消息队列RocketMq。未学习的知识点依然很多，2019年，列下学习计划，不断地总结，不断地反思。</p><p>​    现在是2月份，今天给自己定个目标，希望自己可以跟着目标走，不迷茫，每天活的充实。</p><pre><code>1. zookeeper（思想、理论）2. 缓存相关（思想、理论）3. 多线程4. JVM5. 设计模式6. 分布式相关</code></pre>]]></content>
      
      <categories>
          
          <category> 学习计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019学习计划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMq理解</title>
      <link href="/2018/12/06/RocketMq%E7%90%86%E8%A7%A3/"/>
      <url>/2018/12/06/RocketMq%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>producer，nameServer，broker，consumer</p><p>nameServer无状态，可以集群，互相不影响，独立。</p><p>broker是以group为单位提供服务。</p><p>b1 b2 b3 的group都是order-create-group，那么b1 b2 b3构成一个单位，默认每个broker都有4个队列，那就是12个队列，consumer交叉式连接，达到负载均衡的目的。b1 b2 b3是三个主，可以有自己的从。</p><p>最合适的方案：多master多slave（同步复制SYNC_MASTER），异步刷盘（ASYNC_FLUSH）</p><p>其中最主要的两个，事务消息，顺序消息？</p><p>事务消息：</p><p>首先producer发送一个half消息到rocketMq，然后rocket</p>]]></content>
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMq名词介绍</title>
      <link href="/2018/11/06/RocketMq/"/>
      <url>/2018/11/06/RocketMq/</url>
      <content type="html"><![CDATA[<h3 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h3><hr><h5 id="Name-Server"><a href="#Name-Server" class="headerlink" title="Name Server"></a>Name Server</h5><p><em>介绍：类始于zookeeper在dubbo服务中的作用，作为寻址服务，用于把Broker的路由信息做聚合，客户端依靠NameServer去获取对应topic的路由信息，从而决定对哪些Broker做连接</em></p><ul><li>Name Server之间采取share-nothing的设计，互不通信。</li><li>对于一个Name Server集群列表，客户端连接Name Server的时候，只会选择随机连接一个节点，以做到负载均衡。</li><li>Name Server的所有状态都从Broker上报而来，本身不存储任何状态，不会影响和Broker的通讯，简而言之：Name Server如果挂了，不会影响客户端和正常的Broker之间的通讯，但是在挂掉之后新增的Broker客户端是感知不到的。</li></ul><h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><p><em>介绍：处理消息存储，转发等处理的服务器</em></p><ul><li>Broker是以group分开，每个group只允许一个master，若干个slave</li><li>只有master才能进行写入操作，slave不允许</li><li>slave从master中同步数据。同步策略取决于master的配置，可以采用同步双写，异步复制两种。</li><li>客户端消费可以从master和slave消费。在默认情况下，消费者都从master消费，在master挂掉后，客户端由于从NameServer中感知到Broker挂机，就会从slave消费。</li><li>Broker向所有的NameServer结点建立长连接，注册topic信息。</li></ul><h4 id="PushConsumer"><a href="#PushConsumer" class="headerlink" title="PushConsumer"></a>PushConsumer</h4><p><em>推送模式（RocketMq使用的是长轮询）的消费者。消息能及时被消费，使用简单。</em></p><h4 id="PullConsumer"><a href="#PullConsumer" class="headerlink" title="PullConsumer"></a>PullConsumer</h4><p><em>拉取模式的消费者，应用主动控制拉取的时机，怎么拉取，怎么消费等。主动权更高。</em></p><h4 id="Producer-Group"><a href="#Producer-Group" class="headerlink" title="Producer Group"></a>Producer Group</h4><p><em>标识发送同一类消息的生产者，通常发送逻辑一致。发送普通消息的时候，仅标识使用，并无特别用处。  若事务消息，如果某天发送某  条消息的producer-A宕机，是的事务消息一直处于PREPARED状态并超时，则broker会会查同一个group的其他producer-B，确定这条消息应该commit还是rollback。（已阉割此功能）</em></p><h4 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h4><p><em>标识一类消费者的集合名称，这类消费者通常消费一类消息，且消费逻辑一致。同一个Consumer Group下的各个实例将共同消费topic的消息，起到负载均衡的作用。</em></p><p><em>消费进度以Consumer Group为粒度管理，不同Consumer Group之间消费进度彼此不受影响，即消息A被Consumer Group1消费过，也会在给Consumer Group2消费。</em></p><p><em>注：RocketMQ要求同一个Consumer Group的消费者必须要拥有相同的注册信息，即必须要一样的topic(并且tag也一样)。</em></p><h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><p><em>标识一类消息的逻辑名字，消息的逻辑管理单位。无论消息生成还是消费，都需要指定Topic。</em></p><h4 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h4><p><em>比topic粒度更细，同一个topic的消息虽然逻辑管理一样，但是消费topic的时候，如果订阅的时候指定的是tagA，那么tagB的消息将不会投递，也就不会消费。</em></p><h4 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h4><p><em>简称Queue或Q，一个Topic将有若干个Q，若Topic同时创建在不同的Broker，则不同的Broker上都有若干Q，消息将物理的存储落在不同Broker结点上，具有水平扩展的能力。</em></p><p><em>无论生产者还是消费者，实际的生成和消费都是针对Q级别。例如producer发送消息的时候，会预先选择（默认轮询）好该Topic下面的某一条Q发送；Consumer消费的时候也会负载均衡地分配若干个Q，只拉取对应Q的消息。</em></p><p><em>每一条message queue均对应一个文件，这个文件存储了实际消息的索引信息。并且即使文件被删除，也能通过实际纯粹的消息文件（commit log）恢复回来。</em></p><h4 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a>Offset</h4><p><em>偏移量，可以认为一条逻辑的message queue是无限长的数组。一条消息进来下标就会涨1。下标就是offset。</em></p><p><em>一条message queue中的max offset表示消息的最大offset。max offset= 最新offset+1。</em></p><p><em>min offset 则标识现存在的最小offset。</em></p><p><em>消息存储一段时间后，消息会被物理地从磁盘删除，message queue的min offset也就对应增长。这意味着比min offset要小的那些消息已经不在broker上，无法被消费。</em></p><h4 id="Consumer-Offset"><a href="#Consumer-Offset" class="headerlink" title="Consumer Offset"></a>Consumer Offset</h4><p><em>用于标记Consumer group在一条逻辑Message Queue上，消息消费到哪里了。</em></p><ul><li><em>注：从源码上看，这个数值是最新消费的那条消息的offset+1，所以实际上这个值存储的是【下次拉取的话，从哪里开始拉取的offset】。</em></li></ul><p><em>消费者拉取消息的时候需要指定offset，broker不主动推送消息，而是接受到请求的时候把存储的对应offset的消息返回给客户端。这个offset在成功消费后会更新到内存，并定时持久化。在集群消费模式下，会同步持久化到broker。在广播模式下，会持久化到本地文件。</em></p><p><em>实例重启的时候会获取持久化的Consumer offset，用以决定从哪里开始消费。</em></p><h4 id="集群消费"><a href="#集群消费" class="headerlink" title="集群消费"></a>集群消费</h4><p><em>消费者的一种消费模式。一个Consumer Group中的各个Consumer实例分摊去消费消息，即一条消息只会投递到一个Consumer group下面的一个实例。</em></p><p><em>实际上，每个Consumer是平均分摊Message Queue的去做拉取消费。例如某个Topic有3条Q，其中一个Consumer Group有3个实例（可能是3个进程或者3台机器），那么每个实例只消费其中的一条Q。</em></p><p><em>而由Producer发送消息的时候是轮询所有的Q，所以消息就会平均的散落在不同的Q上，可以认为Q上的消息是平均的。那么实例也就平均地消费消息了。</em></p><p><em>这种模式下，消费进度的存储会持久化到Broker。</em></p><h4 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h4><p><em>消费者的一种消费模式。消息将对一个Consumer Group的各个实例都投递一遍。</em></p><p><em>实际上，是一个消费组下的每个消费者实例都获取到了topic下面的每个Message Queue去拉取消息。所以消息会投递到每个消费者实例。</em></p><p><em>这种模式下，消费进度会存储持久化到实例本地。</em></p><h4 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h4><p><em>消费消息的顺序要同发送消息的顺序一致。由于Consumer消费消息的时候是针对Message Queue顺序拉取并开始消费，且一条Message Queue只会给一个消费者（集群模式下），所以能够保证同一个消费者对于Q上消息的消费是顺序的开始消费（不一定顺序消费完成，因为消费可能并行）。</em></p><p><em>在RocketMQ中，顺序消费主要指的都是Queue级别的局部顺序。这一类消息为满足顺序性，必须Producer单线程顺序发送，且发送到同一个队列，这样Consumer就可以按照Producer发送的顺序去消费消息。</em></p><p><em>生产者发送的时候可以用MessageQueueSelector为某一批消息选择同一个Queue，则这一批消息的消费将是顺序消息（并由同一个Consumer完成消费）。或者Message Queue的数量只有1，但这样消费的实例只能有一个，多出来的实例都会空跑。</em></p><h4 id="普通顺序消息"><a href="#普通顺序消息" class="headerlink" title="普通顺序消息"></a>普通顺序消息</h4><p><em>顺序消息的一种，正常情况下可以保证完全的顺序消息，但是一旦发生异常，Broker宕机或重启，由于队列总数发生变化，消费者会触发负载均衡，而默认地负载均衡算法采取哈希取模平均，这样负载均衡分配到定位的队列会发生变化，使得队列可能分配到别的实例上，则会短暂性的出现消息顺序不一致。</em></p><p><em>如果业务能容忍在集群异常情况下（某个Broker宕机或重启），消息短暂的乱序，使用普通顺序方式最合适。</em></p><h4 id="严格顺序消息"><a href="#严格顺序消息" class="headerlink" title="严格顺序消息"></a>严格顺序消息</h4><p><em>顺序消息的一种，无论正常异常情况都能保证顺序，但是牺牲了分布式failover（失效备援）特性，即Broker集群中只要有一台机器不可用，则整个集群都不可用，服务可用性大大降低。</em></p><p><em>如果服务器部署为同步双写模式，此缺陷可通过备机自动切换为主避免，不过依然会存在几分钟的服务不可用。</em></p>]]></content>
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高并发秒杀系统设计</title>
      <link href="/2018/08/02/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/08/02/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><p>小米在新品发布之后，往往会采用饥饿营销模式🤢，并且在整点抢购手机(比如：5万部小米8)，这个时候会出现秒杀的用户远大于手机库存的情况，如何做到以下两点？</p><ol><li>网站不会因为高流量瘫痪</li><li>防止多卖或者库存不为负数</li></ol><h3 id="技术分析与方案："><a href="#技术分析与方案：" class="headerlink" title="技术分析与方案："></a>技术分析与方案：</h3><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><ol><li>限流：鉴于只有少部分用户能够秒杀成功，所以要限制大部分流量，只允许少部分流量进入服务后端。</li><li>削锋：在秒杀的时候会产生瞬间的高流量，把高流量转换成一段时间的平稳的流量。</li><li>内存缓存：避免击穿数据库，而且秒杀大多数是请求多，读写少，缓存场景比较适合。</li></ol><h5 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h5><ol><li><p>前端方案</p><ol><li><strong>用户限流：</strong>在某一时间段内只允许用户提交一次请求，比如可以采取IP限流</li><li><strong>禁止重复提交：</strong>用户提交之后按钮置灰，禁止重复提交 </li><li><strong>页面静态化：</strong>将活动页面上的所有可以静态的元素全部静态化，并尽量减少动态元素。通过CDN来抗峰值。</li><li><strong>验证码</strong>：在秒杀的时候加入，验证码或者小游戏，踢到大部分流量。</li></ol></li><li><p>后端方案</p><ol><li><strong>排队队列长度</strong>：队列的长度可以设置为库存的2倍或者根据具体情况来定(防止少卖的情况发生)，当超过这个长度，直接返回秒杀已售罄。采用Redis的原子计数器（使用Redis的set结构可以做到去重，具体根据业务场景定），每产生一次请求increase一次，超过规定长度，返回秒杀已售罄，这样就限制了可参与秒杀的用户数量</li><li><strong>消息队列</strong>：下单的操作，直接丢到消息队列中，异步返回排队中。采用Apache的RocketMq消息队列</li><li><strong>缓存</strong>：使用缓存，提高读写效率。采用Redis</li></ol></li><li><p>UML图</p><ol><li><p><img src="https://upload-images.jianshu.io/upload_images/6284737-61a84670f6b38430.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>备注</strong>：前端会不断轮询/**/result接口，查询秒杀结果。</p></li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀系统方案设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018学习计划</title>
      <link href="/2018/06/02/2018%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
      <url>/2018/06/02/2018%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      <content type="html"><![CDATA[<h2 id="2018学习计划"><a href="#2018学习计划" class="headerlink" title="2018学习计划"></a>2018学习计划</h2><p>​    2017年学习的一年，准确的说是半年吧，看了很多书，也做了很多笔记，后面姐姐来了之后，学习就落下了，今年一年已经快过去一小半了，是时候继续学习了，战斗吧，骚年。进入新公司，投入百分之120的努力，学习投入百分之100的努力，希望每天都可以看到自己的成长和收获。</p><p>​    学习不能囫囵吞枣，还是要一个一个来，逐个击破，切记不能急躁，要稳住，稳住，不然后期乏力，打不了团，上不了台面。知识点：JVM，redis，zookeeper，rocketmq，多线程，netty，Spring cloud，Java基础，设计模式，今年核心必须要掌握的知识点：</p><h5 id="RocketMq（两个月）"><a href="#RocketMq（两个月）" class="headerlink" title="RocketMq（两个月）"></a>RocketMq（两个月）</h5><blockquote><p>主要作用：</p><p>主要解决应用耦合，异步消息，流量削锋等问题。实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。</p><p>目标：</p><ol><li>做一个抢购的案例，可以做到10000人同时购买一件商品，只有1000个人可以下单，仅仅只有一个人可以购买成功。</li><li>消息的发送以及监控。</li></ol></blockquote><h5 id="Zookeeper（两个月）"><a href="#Zookeeper（两个月）" class="headerlink" title="Zookeeper（两个月）"></a>Zookeeper（两个月）</h5><blockquote><p>目标：</p><ol><li>Zookeeper 的实际场景应用。</li><li>Zookeeper 的临时节点存储信息等常用操作。</li><li>分布式锁的实现。</li></ol></blockquote><h5 id="Redis（一个月）"><a href="#Redis（一个月）" class="headerlink" title="Redis（一个月）"></a>Redis（一个月）</h5><blockquote><p>目标：</p><ol><li>不能仅限于理论知识，把技术玩到项目中去。</li><li>缓存的一些优化，处理，比如：定时同步，缓存击穿等等。</li></ol></blockquote><h5 id="JVM（两个月）"><a href="#JVM（两个月）" class="headerlink" title="JVM（两个月）"></a>JVM（两个月）</h5><blockquote><p>目标：</p><ol><li>看得懂日志，可以分析日志，当发生内存泄漏或者内存不足的时候可以定位问题。</li><li>熟练运用好jprofiler工具。</li></ol></blockquote><h5 id="多线程（两个月）"><a href="#多线程（两个月）" class="headerlink" title="多线程（两个月）"></a>多线程（两个月）</h5><blockquote><p>目标：</p><ol><li>能够明显感觉多线程带来的性能的提升。</li><li>实际运用多线程的例子，而不是理论知识。</li></ol></blockquote><h5 id="Netty（暂且仅限会用即可）"><a href="#Netty（暂且仅限会用即可）" class="headerlink" title="Netty（暂且仅限会用即可）"></a>Netty（暂且仅限会用即可）</h5><blockquote><p>目标：</p><ol><li>在现有的框架基础下，进行开发，知道各个配置的作用。</li></ol></blockquote><h5 id="Spring-Cloud（不急，等待前面这些学习完了，来玩这个）"><a href="#Spring-Cloud（不急，等待前面这些学习完了，来玩这个）" class="headerlink" title="Spring Cloud（不急，等待前面这些学习完了，来玩这个）"></a>Spring Cloud（不急，等待前面这些学习完了，来玩这个）</h5><blockquote><p>目标：</p><ol><li>根据程序员DD的博客来学习。</li></ol></blockquote><p>​    学习任何一个知识点，都应该做到，首先把这个知识点宏观上理解它的用处，然后并实践，在实践的过程中会遇到很多坑，解决问题，然后在回过头来，看源代码，理解。    </p><p>​    学习的顺序，每一个都很重要，但是还是要写下规划，第一先弄透RocketMq，这个在分布式中很重要，预计花费两个月时间学习这个，然后学习zookeeper，因为公司项目里面有用到这个，而且这个是时候学习下了，时间两个月时间学习，然后在学习缓存，提高高度，应用到实际项目中，然后在学习多线程和JVM，最后学习Spring cloud。就这么愉快的决定了，同样的问题，再次去看待，收获肯定不一样。</p>]]></content>
      
      <categories>
          
          <category> 学习计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2018学习计划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hashmap深入研究-1</title>
      <link href="/2018/04/27/hashMap%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6-1/"/>
      <url>/2018/04/27/hashMap%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6-1/</url>
      <content type="html"><![CDATA[<h4 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h4><ul><li>数据结构中有数组和链表来实现对数据的存储，但这两者基本上是两个极端。所有的数据结构都可以用这两个基本结构来构造的</li><li><strong>数组</strong>：数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；</li><li><strong>链表</strong>：链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。</li><li><strong>哈希表</strong>（(Hash table）：由数组+链表组成的。既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。实际上hashMap是一个链表散列</li></ul><hr><h4 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h4><ul><li>hashMap是一个用于存储key-value键值对的集合，每一个键值对也被叫做Entry。这些个键值对分散存储在一个数组当中，这个数组就是HaspMap的主干。</li><li>总体上看，Hashmap分为很多个数组，每一个数组里面存放着一个链表，结构图如下。</li></ul><h5 id="数据结构图形表示："><a href="#数据结构图形表示：" class="headerlink" title="数据结构图形表示："></a>数据结构图形表示：</h5><ul><li>HashMap的<strong>数组</strong>每一个元素的初始值都是Null。<blockquote><p><img src="http://upload-images.jianshu.io/upload_images/6284737-955ed6f84da5404c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote></li><li>详细的结构<blockquote><p><img src="http://upload-images.jianshu.io/upload_images/6284737-ee3a40ebee689321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><h4 id="put方法的原理："><a href="#put方法的原理：" class="headerlink" title="put方法的原理："></a>put方法的原理：</h4></li><li><p>比如调用hashMap.put(“apple”,0),插入一个key为”apple”的元素。这时候我们需要利用一个哈希函数来确定Entry的插入位置(index)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = Hash(&quot;apple&quot;)</span><br></pre></td></tr></table></figure></li><li><p>假定最后计算的index为2，那么结果如下：</p><blockquote><p><img src="http://upload-images.jianshu.io/upload_images/6284737-45f5586d614337ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>但是，因为HashMap的长度是有限的，当插入的Entry越来越多的时候，会出现index冲突的情况，比如两个值计算的index都是2，这个时候就可以利用链表来解决了<br><img src="http://upload-images.jianshu.io/upload_images/6284737-5e5613ceffe569da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>HashMap 数组的每一个元素不止包含一个Entry(键值对)对象，也包含一个链表的头结点，每一个Entry对象通过next指针指向它的下一个Entry节点(链表)，当新来的Entry映射到冲突的数组位置时，只需要插入到对应的链表即可：<br><img src="http://upload-images.jianshu.io/upload_images/6284737-84acbc1cd3522e17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>需要注意的是，新来的Entry节点插入链表时，使用的是”头插法”，这样是因为HashMap的发明者认为后插入的Entry被查找的可能性更大</li></ul></blockquote></li></ul><h4 id="Get方法的原理"><a href="#Get方法的原理" class="headerlink" title="Get方法的原理"></a>Get方法的原理</h4><ul><li><p>首先会根据输入的Key做一次Hash映射，得到对应的index：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = Hash(&quot;apple&quot;)</span><br></pre></td></tr></table></figure></li><li><p>由于刚才说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候需要顺着对应链表的头节点，一个一个向下来查找(链表)</p><blockquote><p><img src="http://upload-images.jianshu.io/upload_images/6284737-ad7cd5d1e3d73adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote></li><li>第一步，我们查看的是头节点Entry6，它的key是 banana很明显不是。</li><li>第二部，我们查看的next几点Entry1，它的key是 apple，正是结果。</li></ul><h4 id="HashMap的默认长度是16，以后每次必须是2的幂"><a href="#HashMap的默认长度是16，以后每次必须是2的幂" class="headerlink" title="HashMap的默认长度是16，以后每次必须是2的幂"></a>HashMap的默认长度是16，以后每次必须是2的幂</h4><p><img src="https://upload-images.jianshu.io/upload_images/6284737-54c921896cf6134d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>说明：</li></ul><ol><li>&amp; 按位与：只有对应的两个二进位均为1时，结果位才为1 ，否则为0。</li><li>^ 按位异或：当两对应的二进位相异时，结果为1</li><li>符号&gt;&gt;&gt;：&gt;&gt;(按位右移)，&lt;&lt;(按位左移)，&gt;&gt;&gt;(按位右移不足补0),表示无符号右移！</li></ol><ul><li>下面演示下以”book”为例的整个过程：</li></ul><ol><li>计算book的hashcode，结果为十进制的3029737，二进制是10111000111010111101001.</li><li>假定默认长度是16，Length-1是15，二进制就是1111</li><li>根据公式，做与运算，结果是1001，十进制就是9.</li><li>假定默认长度是10，Lnegth-1是9，二进制就是1001</li><li>根据公式，结果也是1001，十进制是9，换一个HashCode，比如是1011100011101011101111，计算结果依然是1001</li><li>由于舒建雄看不懂，特此加注：如果不是1111 只要出现0的，也就意味着计算的结果出现的也有0，比如 1011 结果肯定是X0XX<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5></li></ol><ul><li>当hashMap长度不为16的2的幂时候，出现冲突的几率会更大一些，甚至有些结果永远不会出现。</li><li>可以说，Hash算法最终得到的index结果，完全取决于key的HashCode值的最后几位。1111或者11111或者111111…都是16的2的幂，是为了保证算法均匀。</li></ul>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
