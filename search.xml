<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>2018学习计划!</title>
      <link href="/2018/05/04/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
      <url>/2018/05/04/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      <content type="html"><![CDATA[<h2 id="2018学习计划"><a href="#2018学习计划" class="headerlink" title="2018学习计划"></a>2018学习计划</h2><p>​    2017年学习的一年，准确的说是半年吧，看了很多书，也做了很多笔记，后面姐姐来了之后，学习就落下了，今年一年已经快过去一小半了，是时候继续学习了，战斗吧，骚年。进入新公司，投入百分之120的努力，学习投入百分之100的努力，希望每天都可以看到自己的成长和收获。</p><p>​    学习不能囫囵吞枣，还是要一个一个来，逐个击破，切记不能急躁，要稳住，稳住，不然后期乏力，打不了团，上不了台面。知识点：JVM，redis，zookeeper，rocketmq，多线程，netty，Spring cloud，Java基础，设计模式，今年核心必须要掌握的知识点：</p><h5 id="RocketMq（两个月）"><a href="#RocketMq（两个月）" class="headerlink" title="RocketMq（两个月）"></a>RocketMq（两个月）</h5><blockquote><p>主要作用：</p><p>主要解决应用耦合，异步消息，流量削锋等问题。实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。</p><p>目标：</p><ol><li>做一个抢购的案例，可以做到10000人同时购买一件商品，只有1000个人可以下单，仅仅只有一个人可以购买成功。</li><li>消息的发送以及监控。</li></ol></blockquote><h5 id="Zookeeper（两个月）"><a href="#Zookeeper（两个月）" class="headerlink" title="Zookeeper（两个月）"></a>Zookeeper（两个月）</h5><blockquote><p>目标：</p><ol><li>Zookeeper 的实际场景应用。</li><li>Zookeeper 的临时节点存储信息等常用操作。</li><li>分布式锁的实现。</li></ol></blockquote><h5 id="Redis（一个月）"><a href="#Redis（一个月）" class="headerlink" title="Redis（一个月）"></a>Redis（一个月）</h5><blockquote><p>目标：</p><ol><li>不能仅限于理论知识，把技术玩到项目中去。</li><li>缓存的一些优化，处理，比如：定时同步，缓存击穿等等。</li></ol></blockquote><h5 id="JVM（两个月）"><a href="#JVM（两个月）" class="headerlink" title="JVM（两个月）"></a>JVM（两个月）</h5><blockquote><p>目标：</p><ol><li>看得懂日志，可以分析日志，当发生内存泄漏或者内存不足的时候可以定位问题。</li><li>熟练运用好jprofiler工具。</li></ol></blockquote><h5 id="多线程（两个月）"><a href="#多线程（两个月）" class="headerlink" title="多线程（两个月）"></a>多线程（两个月）</h5><blockquote><p>目标：</p><ol><li>能够明显感觉多线程带来的性能的提升。</li><li>实际运用多线程的例子，而不是理论知识。</li></ol></blockquote><h5 id="Netty（暂且仅限会用即可）"><a href="#Netty（暂且仅限会用即可）" class="headerlink" title="Netty（暂且仅限会用即可）"></a>Netty（暂且仅限会用即可）</h5><blockquote><p>目标：</p><ol><li>在现有的框架基础下，进行开发，知道各个配置的作用。</li></ol></blockquote><h5 id="Spring-Cloud（不急，等待前面这些学习完了，来玩这个）"><a href="#Spring-Cloud（不急，等待前面这些学习完了，来玩这个）" class="headerlink" title="Spring Cloud（不急，等待前面这些学习完了，来玩这个）"></a>Spring Cloud（不急，等待前面这些学习完了，来玩这个）</h5><blockquote><p>目标：</p><ol><li>根据程序员DD的博客来学习。</li></ol></blockquote><p>​    学习的顺序，每一个都很重要，但是还是要写下规划，第一先弄透RocketMq，这个在分布式中很重要，预计花费两个月时间学习这个，然后学习zookeeper，因为公司项目里面有用到这个，而且这个是时候学习下了，时间两个月时间学习，然后在学习缓存，提高高度，应用到实际项目中，然后在学习多线程和JVM，最后学习Spring cloud。就这么愉快的决定了，同样的问题，再次去看待，收获肯定不一样。<br>​    </p>]]></content>
      
      <categories>
          
          <category> 学习计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习计划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈对hashmap的理解!</title>
      <link href="/2018/04/07/hashMap%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6-1/"/>
      <url>/2018/04/07/hashMap%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6-1/</url>
      <content type="html"><![CDATA[<h4 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h4><ul><li>数据结构中有数组和链表来实现对数据的存储，但这两者基本上是两个极端。所有的数据结构都可以用这两个基本结构来构造的</li><li><strong>数组</strong>：数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；</li><li><strong>链表</strong>：链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。</li><li><strong>哈希表</strong>（(Hash table）：由数组+链表组成的。既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。实际上hashMap是一个链表散列</li></ul><hr><h4 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h4><ul><li>hashMap是一个用于存储key-value键值对的集合，每一个键值对也被叫做Entry。这些个键值对分散存储在一个数组当中，这个数组就是HaspMap的主干。</li><li>总体上看，Hashmap分为很多个数组，每一个数组里面存放着一个链表，结构图如下。</li></ul><h5 id="数据结构图形表示："><a href="#数据结构图形表示：" class="headerlink" title="数据结构图形表示："></a>数据结构图形表示：</h5><ul><li>HashMap的<strong>数组</strong>每一个元素的初始值都是Null。<blockquote><p><img src="http://upload-images.jianshu.io/upload_images/6284737-955ed6f84da5404c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote></li><li>详细的结构<blockquote><p><img src="http://upload-images.jianshu.io/upload_images/6284737-ee3a40ebee689321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><h4 id="put方法的原理："><a href="#put方法的原理：" class="headerlink" title="put方法的原理："></a>put方法的原理：</h4></li><li><p>比如调用hashMap.put(“apple”,0),插入一个key为”apple”的元素。这时候我们需要利用一个哈希函数来确定Entry的插入位置(index)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = Hash(&quot;apple&quot;)</span><br></pre></td></tr></table></figure></li><li><p>假定最后计算的index为2，那么结果如下：</p><blockquote><p><img src="http://upload-images.jianshu.io/upload_images/6284737-45f5586d614337ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>但是，因为HashMap的长度是有限的，当插入的Entry越来越多的时候，会出现index冲突的情况，比如两个值计算的index都是2，这个时候就可以利用链表来解决了<br><img src="http://upload-images.jianshu.io/upload_images/6284737-5e5613ceffe569da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>HashMap 数组的每一个元素不止包含一个Entry(键值对)对象，也包含一个链表的头结点，每一个Entry对象通过next指针指向它的下一个Entry节点(链表)，当新来的Entry映射到冲突的数组位置时，只需要插入到对应的链表即可：<br><img src="http://upload-images.jianshu.io/upload_images/6284737-84acbc1cd3522e17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>需要注意的是，新来的Entry节点插入链表时，使用的是”头插法”，这样是因为HashMap的发明者认为后插入的Entry被查找的可能性更大</li></ul></blockquote></li></ul><h4 id="Get方法的原理"><a href="#Get方法的原理" class="headerlink" title="Get方法的原理"></a>Get方法的原理</h4><ul><li><p>首先会根据输入的Key做一次Hash映射，得到对应的index：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = Hash(&quot;apple&quot;)</span><br></pre></td></tr></table></figure></li><li><p>由于刚才说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候需要顺着对应链表的头节点，一个一个向下来查找(链表)</p><blockquote><p><img src="http://upload-images.jianshu.io/upload_images/6284737-ad7cd5d1e3d73adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote></li><li>第一步，我们查看的是头节点Entry6，它的key是 banana很明显不是。</li><li>第二部，我们查看的next几点Entry1，它的key是 apple，正是结果。</li></ul><h4 id="HashMap的默认长度是16，以后每次必须是2的幂"><a href="#HashMap的默认长度是16，以后每次必须是2的幂" class="headerlink" title="HashMap的默认长度是16，以后每次必须是2的幂"></a>HashMap的默认长度是16，以后每次必须是2的幂</h4><ul><li><p>key映射到HashMap数组的对应位置，会用到一个Hash函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = Hash(&quot;apple&quot;)</span><br></pre></td></tr></table></figure></li><li><p>为了实现高效的Hash算法，HashMap的发明者采用了位运算的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = HashCode(key)&amp;(Length-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>下面演示下以”book”为例的整个过程：</p></li></ul><ol><li>计算book的hashcode，结果为十进制的3029737，二进制是10111000111010111101001.</li><li>假定默认长度是16，Length-1是15，二进制就是1111</li><li>根据公式，做与运算，结果是1001，十进制就是9.</li><li>假定默认长度是10，Lnegth-1是9，二进制就是1001</li><li>根据公式，结果也是1001，十进制是9，换一个HashCode，比如是1011100011101011101111，计算结果依然是1001</li><li>由于舒建雄看不懂，特此加注：如果不是1111 只要出现0的，也就意味着计算的结果出现的也有0，比如 1011 结果肯定是X0XX<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5></li></ol><ul><li>当hashMap长度不为16的2的幂时候，出现冲突的几率会更大一些，甚至有些结果永远不会出现。</li><li>可以说，Hash算法最终得到的index结果，完全取决于key的HashCode值的最后几位。1111或者11111或者111111…都是16的2的幂，是为了保证算法均匀。</li></ul><h4 id="HashMap在高并发情况下如何处理？（后续跟进）"><a href="#HashMap在高并发情况下如何处理？（后续跟进）" class="headerlink" title="HashMap在高并发情况下如何处理？（后续跟进）"></a>HashMap在高并发情况下如何处理？（后续跟进）</h4>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
