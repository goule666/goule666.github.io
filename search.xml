<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>抽象类、接口、普通类</title>
      <link href="/2019/10/10/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E6%99%AE%E9%80%9A%E7%B1%BB/"/>
      <url>/2019/10/10/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E6%99%AE%E9%80%9A%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p>老生常谈的问题，这里记录一下：</p><h1 id="抽象类、普通类、接口"><a href="#抽象类、普通类、接口" class="headerlink" title="抽象类、普通类、接口"></a>抽象类、普通类、接口</h1><h3 id="抽象类和普通类："><a href="#抽象类和普通类：" class="headerlink" title="抽象类和普通类："></a>抽象类和普通类：</h3><h4 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h4><ol><li>实现接口和继承抽象类方面：<ol><li>普通类实现接口，则必须实现这个接口的所有非default方法。</li><li>抽象类实现接口，可以不实现接口的所有方法，但是在使用抽象类的时候（创建匿名类），接口中的非default方法必须在匿名类中实现，不然会出现编译报错</li><li>普通类继承抽象类，则必须实现这个抽象类中的abstract方法</li><li>抽象类继承抽象类，不必实现abstract方法<ol start="2"><li>实例化：</li></ol></li><li>抽象类不可实例化，可以通过创建匿名类的方式来使用，代码例子见代码1.</li></ol></li></ol><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>抽象类的概念是由普通类的”共性”产生的，集中描述其共性，就会产生一个抽象性的概念。</p><p>比如：N个普通类，只有少数几个普通类的A方法是个性的，其他的普通类的A方法是相同的，那么A方法可以抽象出来放在抽象类中去实现，这样只需要子类去继承抽象类即可。</p><h3 id="抽象类和接口："><a href="#抽象类和接口：" class="headerlink" title="抽象类和接口："></a>抽象类和接口：</h3><h4 id="区别与联系-1"><a href="#区别与联系-1" class="headerlink" title="区别与联系"></a>区别与联系</h4><ol><li>抽象类和接口一样都无法实例化，但是抽象类具有构造器，接口不具有构造器</li><li>接口里面的变量是不可变常量，抽象类的变量可以是任意属性</li><li><strong>抽象类和接口都是用来抽象具体对象的，接口的抽象级别更高</strong></li></ol><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>抽象类表示的是，这个对象是什么，共性有哪些。接口表示的是，这个对象拥有哪些功能，能做什么。</p><p>比如：男人和女人，抽象类是人类，猫和狗的抽象类是宠物类，人类可以吃东西，宠物类也可以吃东西。所以吃东西应该放在接口中，人类和宠物类是两个抽象类</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ol><li><p>代码1</p><ol><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class com.goule666.study.witness.java.basic.abstractclass.Test$1</span></span><br><span class="line">        <span class="comment">//匿名类</span></span><br><span class="line">        AbstractRemoteCallBack callBack = <span class="keyword">new</span> AbstractRemoteCallBack()&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 成功</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> data data</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"成功"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="抽象类、接口类、普通类的类图如下"><a href="#抽象类、接口类、普通类的类图如下" class="headerlink" title="抽象类、接口类、普通类的类图如下"></a>抽象类、接口类、普通类的类图如下</h3><ol><li>Demo 中的UML类图如下：<ol><li><img src="/Users/wlnie/Library/Application%20Support/typora-user-images/image-20191010141258998.png" alt="image-20191010141258998"></li></ol></li><li></li></ol>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>责任链模式</title>
      <link href="/2019/10/09/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/10/09/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>为了避免请求的发送者和接受者之间的耦合关系，使多个对象都有机会处理请求。将这些对象连接成一条链，并沿着这条链传递该请求，直到有对象处理他为止。</p><h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h3><p>对于一个请求，存在多个处理对象都需要有机会处理该请求，然后将这些对象连接成一条链，请求沿着这条链传递下去，直到有对象处理为止</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>对于一个请求，存在多个对象都需要机会对其处理或者多个对象中的某一个（未知的）需要对其处理的时候，责任链模式非常适合。</p><ol><li>源码中的案例：<ol><li>spring security（VirtualFilterChain、FilterChain、Filter、Filter的实现类）</li><li>servlet</li></ol></li><li>实际业务中的案例：<ol><li>本demo</li></ol></li></ol><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><ol><li><p>先放上spring security的责任链模式的类图：</p><ol><li>链接口和链的实现类<ol><li><img src="/Users/wlnie/Library/Application%20Support/typora-user-images/image-20191009171341828.png" alt="image-20191009171341828"></li></ol></li><li>对象接口和对象的实现类<ol><li><img src="/Users/wlnie/Library/Application%20Support/typora-user-images/image-20191009171548057.png" alt="image-20191009171548057"></li></ol></li></ol></li></ol><ol start="2"><li><p>接下来放上本次demo的类图：</p><ol><li>链接口和链的实现类<ol><li><img src="/Users/wlnie/Library/Application%20Support/typora-user-images/image-20191009170652718.png" alt="image-20191009170652718"></li></ol></li><li>对象接口和对象的实现类<ol><li><img src="/Users/wlnie/Library/Application%20Support/typora-user-images/image-20191009170753958.png" alt="image-20191009170753958"></li></ol></li></ol></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ol><li><p>首先是对象接口和对象的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取水站</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stationHandlerChain 链</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 水站名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getStation</span><span class="params">(StationHandlerChain stationHandlerChain)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StationFourHandlerImpl</span> <span class="keyword">implements</span> <span class="title">StationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取水站</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stationHandlerChain 链</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 水站名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStation</span><span class="params">(StationHandlerChain stationHandlerChain)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"第四方获取水站成功!!!"</span>);</span><br><span class="line"></span><br><span class="line">        stationHandlerChain.getStation();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"娃哈哈水站第四方3号"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StationInnerHandlerImpl</span> <span class="keyword">implements</span> <span class="title">StationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取水站</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stationHandlerChain 链</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 水站名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStation</span><span class="params">(StationHandlerChain stationHandlerChain)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"内部获取水站成功!!!"</span>);</span><br><span class="line"></span><br><span class="line">        stationHandlerChain.getStation();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"娃哈哈水站内部1号"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StationThirdHandlerImpl</span> <span class="keyword">implements</span> <span class="title">StationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取水站</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stationHandlerChain 链</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 水站名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStation</span><span class="params">(StationHandlerChain stationHandlerChain)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"第三方获取水站成功!!!"</span>);</span><br><span class="line">        stationHandlerChain.getStation();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"娃哈哈水站第三方2号"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接着是链的接口和链的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StationHandlerChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加获取水站处理类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 获取水站处理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true or false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">StationHandlerChain <span class="title">addHandler</span><span class="params">(StationHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取水站信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 水站信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">getStation</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StationHandlerChainImpl</span> <span class="keyword">implements</span> <span class="title">StationHandlerChain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; stationList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理类集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;StationHandler&gt; handlerList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加获取水站处理类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 获取水站处理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true or false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StationHandlerChain <span class="title">addHandler</span><span class="params">(StationHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handlerList == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handlerList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        handlerList.add(handler);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取水站信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 水站名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getStation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position == handlerList.size()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"获取水站结束"</span>);</span><br><span class="line">            <span class="keyword">return</span> stationList;</span><br><span class="line">        &#125;</span><br><span class="line">        String station = handlerList.get(position++).getStation(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (station != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stationList.add(station);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stationList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后是test</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StationHandler stationInnerHandler = <span class="keyword">new</span> StationInnerHandlerImpl();</span><br><span class="line">        StationHandler stationThirdHandler = <span class="keyword">new</span> StationThirdHandlerImpl();</span><br><span class="line">        StationHandler stationFourHandler = <span class="keyword">new</span> StationFourHandlerImpl();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        StationHandlerChain chain = <span class="keyword">new</span> StationHandlerChainImpl();</span><br><span class="line">        List&lt;String&gt; stationList = chain</span><br><span class="line">                .addHandler(stationInnerHandler)</span><br><span class="line">                .addHandler(stationThirdHandler)</span><br><span class="line">                .addHandler(stationFourHandler)</span><br><span class="line">                .getStation();</span><br><span class="line">        System.out.println(stationList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>责任链模式本身并不难，难点在于如何结合实际案例。本文恰好是一个比较典型的例子，有多种渠道获取水站的信息，但是具体是哪一个渠道并不知道。后面还可以延伸成，按照处理对象优先级进行排序，如果内部渠道获取到了水站信息则不在继续传递，直到最后一级，做到灵活可配置，这里就不在详细的写出代码了。</li></ol><h3 id="特殊说明"><a href="#特殊说明" class="headerlink" title="特殊说明"></a>特殊说明</h3><p>责任链模式分为两种：纯、不纯。纯的模式一般可以采用策略模式替代，实际应用不纯的场景会更常见一些。</p><ol><li>纯（标准版）：<ol><li>一个处理者对象只能在两个行为里面选择一个，要不处理，要不传递给下一个处理者对象。不允许处理部分责任之后又传递给下一个处理者对象</li><li>在这些处理者对象链中，必须有一个能处理请求</li></ol></li><li>不纯（升级版，比较常用）：<ol><li>允许处理者对象处理请求后在向下传递</li><li>允许请求最终未被任何对象处理</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 责任链模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式</title>
      <link href="/2019/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式是一个长期学习的过程，不需要迫切的去记一些东西，需要理解，然后进行模仿，加深印象并可以熟练运用。<br>我认为以下这些设计模式需特殊注意（源码出场率较高）：</p><ol><li>单例模式 </li><li>简单工厂模式、工厂模式、抽象工厂模式</li><li>策略模式</li><li>责任链模式</li><li>代理模式</li><li>模板方法模式</li><li>观察者模式</li><li>适配器模式</li></ol>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/08/13/ConcurrentHashMap%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6-1/"/>
      <url>/2019/08/13/ConcurrentHashMap%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6-1/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>内存泄漏分析</title>
      <link href="/2019/08/13/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/"/>
      <url>/2019/08/13/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/</url>
      <content type="html"><![CDATA[<p>当CPU load偏高的时候，排除机器本身、上游系统调用增加等问题，分析思路如下：</p><ol><li>查看GC的情况<ol><li>GC频率和STW时间</li></ol></li><li>使用top命令，查看当前占用CPU最高的进程。假如是Java进程，pid是12345<ol><li>命令：top</li></ol></li><li>找出Java进程中，占用最高的前几个的线程pid，并同时观察线程数是不是过多。<ol><li>top -Hp 12345</li></ol></li><li>对这些pid转成16进制，并在当前的堆栈中找到对应的线程<ol><li>保存当前堆栈：jstack 12345 &gt; jstack.log</li></ol></li><li>如果发现占用较高的线程都是GC线程，这个时候把当前堆的信息保存下来<ol><li>保存当前堆：jmap -dump:live,format=b,file=heap.hprof 12345</li></ol></li><li>然后通过jprofiler打开，并分析，重点：<ol><li>Bigger Object前几个</li><li>class实例化前几个</li></ol></li></ol><p>可参考的健康的GC状况：</p><ol><li>YGC频率5S/次</li><li>CMS GC频率不超过1天/次</li><li>每次YGC的时间不超过20ms</li></ol>]]></content>
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存泄漏 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hashmap深入研究-2</title>
      <link href="/2019/07/30/hashMap%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6-2/"/>
      <url>/2019/07/30/hashMap%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6-2/</url>
      <content type="html"><![CDATA[<p>时隔一年，在一次的由浅入深的了解hashMap（jdk 1.8）之后，写下了这篇文章！</p><p>本文将从三个具有代表性的点由浅入深的展开描述：</p><h4 id="1-确定hash桶数组索引位置"><a href="#1-确定hash桶数组索引位置" class="headerlink" title="1. 确定hash桶数组索引位置"></a>1. 确定hash桶数组索引位置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 得到key的hashCode值</span></span><br><span class="line"><span class="keyword">int</span> h = key.hashCode();</span><br><span class="line"><span class="comment">//2. 先移位、然后按位异或运算 扰动函数 与1.7有所不同 目的：尽量均匀</span></span><br><span class="line"><span class="keyword">int</span> h1 = h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line"><span class="comment">//3. 按位与运算(比取模运算速度快)</span></span><br><span class="line"><span class="keyword">int</span> hash = h1 &amp; (length - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="2-put方法详解"><a href="#2-put方法详解" class="headerlink" title="2. put方法详解"></a>2. put方法详解</h4><p>流程图（源自网络）</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/d669d29c.png" alt=""></p><p>然后看jdk8 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        HashMap.Node&lt;K, V&gt;[] tab;</span><br><span class="line">        HashMap.Node&lt;K, V&gt; p;</span><br><span class="line">        <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">//1. table为空则创建</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">//2. 计算index，如果table[index] == null，则代表当前数组上没有元素</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//2.1 直接插入</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            HashMap.Node&lt;K, V&gt; e;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="comment">//3. 节点key已经存在，覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//4. 链是红黑树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> HashMap.TreeNode)</span><br><span class="line">                e = ((HashMap.TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">//5. 链是链表，链的长度小于8</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//5.1 找到链表中最后一个元素</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//5.2 尾插法</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//5.3 如果链表长度超过8 转换成红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//5.2 如果key 存在，覆盖value</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//6. e如果不为空，代表key是重复的，需要覆盖value</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            <span class="comment">//7. 扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-resize"><a href="#3-resize" class="headerlink" title="3. resize"></a>3. resize</h4><p>先讲解1.7的resize过程，然后在跟着1.8的源代码讲解resize做了哪些优化</p><p><strong>jdk1.7的源代码如下</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">        <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">        transfer(newTable);</span><br><span class="line">        <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">        table = newTable;</span><br><span class="line">        <span class="comment">//修改阈值</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>) (newCapacity * loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">        Entry[] src = table;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">            <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">            Entry&lt;K, V&gt; e = src[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">                src[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    Entry&lt;K, V&gt; next = e.next;</span><br><span class="line">                    <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                    <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                    e.next = newTable[i];</span><br><span class="line">                    <span class="comment">//将元素放在数组上</span></span><br><span class="line">                    newTable[i] = e;</span><br><span class="line">                    <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">                    e = next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>1.7存在的问题：在多线程操作中，resize之后，可能存在调用get方法的时候进入死循环，分析如下：</strong></p><p>有一个hashMap，容量设置为2，负载因子为0.75</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapInfiniteLoop</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">"C"</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread1"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">"B"</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread2"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">"A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();        </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>存在两个线程thread1和thread2同时操作一个map，先打上断点让两个线程都debug到transfer（）方法的首行，注意此时，两个线程的数据都已经添加完成，然后执行线程thread1执行到transfer（）的int i = indexFor(e.hash, newCapacity);打上断点，然后让线程thread2执行完成，最后放开断点，线程thread1执行完成。</p><p>先直接说结果，然后在分析，结果：在执行完resize（）方法之后，调用get（）方法，当计算的index是3的时候，会进入死循环，这时Map的数据结构如下图：</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/6eed9aaf.png" alt=""></p><p>分析：</p><ol><li><p>在线程thread2执行完成之后，这个时候map的结构如图：</p><ol><li><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/7df99266.png" alt=""></li></ol></li><li><p>此时，thread1执行</p><ol><li><img src="https://upload-images.jianshu.io/upload_images/6284737-6cc4aceec1a44a23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>在三次循环之后，key(7).next = key(3)、key(3).next = key(7)，所以在get()方法执行的时候，如果index = 3的情况下， 会进入Infinite loop。根本原因是：jdk1.7 hashmap是头插入的方法，并且在扩容之后链表上元素的顺序会发生倒置，比如之前链表顺序是：7-&gt;3，扩容之后如果还在同一个hash桶数组中，会变成3-&gt;7。</li></ol><p><strong>jdk1.8的resize源代码分析如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap.Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        <span class="comment">//1. 原map</span></span><br><span class="line">        HashMap.Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//2.1 如果原map的数组大小已经超过最大值，那就只能任其碰撞了</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.2 没有超过最大值，则扩充为之前的两倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        HashMap.Node&lt;K,V&gt;[] newTab = (HashMap.Node&lt;K,V&gt;[])<span class="keyword">new</span> HashMap.Node[newCap];</span><br><span class="line">        <span class="comment">//3. 扩容之后新的数组</span></span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//3.1 移动元素到新的buckets中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                HashMap.Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//3.2 释放空间</span></span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//3.3 buckets中只有一个元素</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">//3.4 链是红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HashMap.TreeNode)</span><br><span class="line">                        ((HashMap.TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">//3.5 链是链表</span></span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        <span class="comment">//head代表头指针，tail代表尾指针</span></span><br><span class="line">                        HashMap.Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        HashMap.Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        HashMap.Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">//3.6 index不发生变化</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//3.7 index = index + oldCap</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//3.8 元素的index没有发生变化</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//3.9 元素的Index = index + oldCap</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="结束："><a href="#结束：" class="headerlink" title="结束："></a>结束：</h4><p>总的来说，1.8的优化还是很多的（put、resize），网上也有很多性能的对比，这里就不详细描述了，下一篇文章将介绍线程安全的concurrentHashMap。</p>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络IO</title>
      <link href="/2019/07/09/%E7%BD%91%E7%BB%9CIO/"/>
      <url>/2019/07/09/%E7%BD%91%E7%BB%9CIO/</url>
      <content type="html"><![CDATA[<p>每次打开boss直聘都会看到，熟悉网络IO、多线程、集合等巴拉巴拉。</p><p>网络IO，熟悉又陌生的词语，自此，在工作之余，对网络IO、netty展开了学习！</p><p>网络IO，个人觉得可以从两方面来讲，不然很难理解其中的含义。</p><ol><li>Java提供的相关IO的操作类</li><li>操作系统层面的IO操作</li></ol><hr><h4 id="操作系统层面的IO操作（Linux）"><a href="#操作系统层面的IO操作（Linux）" class="headerlink" title="操作系统层面的IO操作（Linux）"></a>操作系统层面的IO操作（Linux）</h4><p>平时用的服务器一般都是以Linux为主，在Linux这样的操作系统中，线程本质上就是一个进程，所以重点看了下Linux的IO模型，在Linux中，共有五种IO模型，分别是：<strong>阻塞IO、非阻塞IO、IO复用、响应驱动IO、异步IO</strong></p><p><strong>到底什么是IO</strong></p><p>首先需要先介绍下到底什么是IO，一般来说，服务器端IO主要分两种：<strong>一是来自网络的IO</strong>，<strong>二是来自文件的IO</strong>，无论是哪一种，系统IO分为两个阶段：<strong>等待就绪</strong>和<strong>操作</strong>，等待就绪的过程是不使用CPU的，是在”空等”，而真正的读写操作是使用CPU的，这个过程很快，通常带宽在1GB/S级别以上。</p><p><strong>阻塞IO模型（图源网络）</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/6284737-01e04f90759852d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>应用进程（线程）通过系统调用==recvfrom==接受数据（阻塞），进入阻塞状态，但是内核数据报未准备好，需要等待（等待就绪），数据报准备好之后，进行数据报的复制（操作），然后返回给应用进程（线程），应用进程（线程）才能结束阻塞状态。</p><p><strong>非阻塞IO模式（图源网络）</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/6284737-40bb3d9f0edb40c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>应用进程通过系统调用==recvfrom==接受数据（非阻塞），操作系统收到之后，数据数据报没有准备好，直接返回error，应用进程收到error后，过段时间会再次系统调用，直到数据报准备好，在多次发送请求的时间段，线程可以做别的事情，所以是非阻塞。</p><p><strong>IO复用（图源网络）</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/6284737-36a3b424f50a9852.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>多个进程的IO可以注册到同一个==select==上，然后统一和内核进行交互，当管道中的某一个请求的数据报准备好之后，返回可读条件，然后进行通过==recvfrom==系统调用（阻塞），复制数据报，最后返回数据。</p><p><strong>响应驱动IO（图源网络）</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/6284737-5c35701f1104d9d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>应用进程向内核注册一个信号处理函数，内核直接返回用户，不阻塞，当数据报准备好的时候，通知应用进程，然后应用进程，调用==recvfrom==调用内核（阻塞），数据报复制好之后，返回。</p><p><strong>异步IO（图源网络）</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/6284737-6d2e688c0ed330f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>应用进程系统调用内核，内核直接返回，然后内核等待就绪和操作自己完成，完成之后通知应用进程。</p><p><strong>总结：</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/6284737-5970706475fe24fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><hr><h3 id="Java提供的相关IO的操作类"><a href="#Java提供的相关IO的操作类" class="headerlink" title="Java提供的相关IO的操作类"></a>Java提供的相关IO的操作类</h3><p>BIO（同步阻塞）、NIO（同步非阻塞）、AIO（异步非阻塞）</p><p><strong>BIO（图源网络）— 一请求一应答模型</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/6284737-1a8aa541ec9f8b7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>acceptor监听服务器端口，用来接受client的连接，当收到client的连接请求之后，为每个client创建一个新的线程进行链路处理，处理完成之后，通过输出流返回给client，典型的一请求一应答通信模型。</p><p><strong>伪异步IO（图源网络）</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/6284737-17af64a58aa9b287.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>引入线程池，降低线程的创建和回收成本，并且可以控制线程的最大数量。</p><p>伪异步IO是BIO的升级版，模型如图所示。acceptor监听服务器端口，用例接受client的连接，然后把后续的任务交给线程池来处理，线程池维护一个消息队列和N个活跃线程，线程池可以设置消息队列的大小和最大线程数，所以这种方式资源是可控的。</p><p>这种方式避免了为每一个请求创建独立线程造成的线程资源耗尽的问题，但是这种方式的底层依然是同步阻塞模型，所以无法根本解决问题。</p><p><strong>NIO（图源网络）</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/6284737-6f59e4800dcfab9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>bossGroup线程组（dubbo中设置线程大小为1）实际是acceptor线程池，用来轮询监听服务器端口，接受客户端的连接请求，生成NioSocketChannel，然后NioSocketChannel注册到workerGroup其中的一个NioEventLoop中，多个Channel可以注册到一个selector中（<strong>I/O多路复用</strong>），<strong>操作（IO操作）</strong>依然是阻塞的，这样可以充分的利用CPU的资源。</p><p><strong>AIO（仅限于理论）</strong></p><p>在Java7之后引入了NIO2，也就是AIO（异步非阻塞），在NIO的网络操作中，提供了同步非阻塞的方法，其<strong>操作（IO操作）</strong>依然是阻塞的，然而AIO，<strong>操作（IO操作）</strong>也是非阻塞的。结果是通过通知的方式告知线程。</p><p>netty曾经尝试过AIO，但是后面放弃了，具体原因较为复杂，附上链接。<a href="https://github.com/netty/netty/issues/2515" target="_blank" rel="noopener">https://github.com/netty/netty/issues/2515</a></p>]]></content>
      
      <categories>
          
          <category> 网络IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单测</title>
      <link href="/2019/07/09/%E5%8D%95%E6%B5%8B-mock/"/>
      <url>/2019/07/09/%E5%8D%95%E6%B5%8B-mock/</url>
      <content type="html"><![CDATA[<p>所有依赖于第三方的接口（数据库、HTTP接口，dubbo接口，即和代码逻辑无关的接口）全部需要mock。</p><ol><li>测试类中的方法需要mock</li><li>测试类中的注入的service需要mock</li><li>参数匹配：any()等等，如果有复杂的用ArgumentMatcher</li></ol><p>第一种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stationEmployeeFacade = spy(stationEmployeeFacade);</span><br><span class="line">doReturn(stationEmployee).when(stationEmployeeFacade).getStationEmployeeByToken(token);</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InjectMocks</span>(测试类)</span><br><span class="line"><span class="meta">@Mock</span>(需要mock的service)</span><br><span class="line">when(stationService.findFirstByOwner(stationEmployee.getId())).thenReturn(station);</span><br></pre></td></tr></table></figure><p>特殊情况：spring加了事务之后需要特殊处理下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">unwrapProxy</span><span class="params">(Object bean)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the given object is a proxy, set the return value as the object</span></span><br><span class="line"><span class="comment">         * being proxied, otherwise return the given object.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (AopUtils.isAopProxy(bean) &amp;&amp; bean <span class="keyword">instanceof</span> Advised) &#123;</span><br><span class="line">            Advised advised = (Advised) bean;</span><br><span class="line">            bean = advised.getTargetSource().getTarget();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 代码规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mockito </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构与算法分析（Java语言描述）</title>
      <link href="/2019/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2019/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>线性表（顺序实现、链式实现）、堆栈（栈）、队列</p><p>二叉树、二叉查找树、平衡二叉树（AVL）、红黑树、堆（完全二叉树）、B树（b-tree）、B+树</p><p>冒泡排序、插入排序、希尔排序、堆排序、归并排序、快速排序</p>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>随笔</title>
      <link href="/2019/05/15/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%88%91/"/>
      <url>/2019/05/15/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%88%91/</url>
      <content type="html"><![CDATA[<p>​    现在是2019-05-15 16:23:19，这几天实在是被杭州的房价恶心🤢了一番，突然想到了回武汉发展，由此而来的随笔，诞生了。</p><p>​    18年4月份入农夫山泉，不可否认，公司氛围啊，什么的都还可以，但是工资一年没有涨，如果19年年底，也就是20年初，工资还没涨的话，或者涨幅少于20%的话，我觉得应该走了，杭州物价，房价一年比一年高，能力肯定也一年比一年强，我不想混吃等死，我重来不嫌麻烦，明年4月份，将面临两种选择，如下：</p><ol><li>辞职在杭州重新找工作，年薪幅度要达到25万左右。</li><li>回武汉找工作，年薪在20万左右。</li></ol><p>不管是在杭州重新找工作也好，还是回武汉找工作也好，都是需要好好准备一番的，说是准备，其实也算是复习吧！目前规划的是：</p><ol><li>分布式专题和性能优化专题看完。周期预算-2个月</li><li><strong>数据结构、计算机网络</strong>、计算机组成、操作系统。前两个作为重点。巩固基础，为进大厂做准备。周期预算-4个月</li><li>刷算法题，提高逻辑思维能力，虽然已经很强了😝，把没走过的路，走一遍。周期预算-2个月</li><li>刷面试题，虽然刷面试题很俗，但是不可否认，也是最有效的方式。周期预算-2个月</li><li>hashMap源码，spring核心源码，学习别人的设计模式。周期预算-2个月</li></ol>]]></content>
      
      <categories>
          
          <category> 6不6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>菜鸟+腾讯（知乎引入）</title>
      <link href="/2019/05/15/%E8%8F%9C%E9%B8%9F+%E8%85%BE%E8%AE%AF%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/05/15/%E8%8F%9C%E9%B8%9F+%E8%85%BE%E8%AE%AF%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>距离4.30号收到阿里实习生意向书也有十天了，整个三四月份也完整的经历了互联网春招的历程。虽然已经收到offer了，但是每天还是不断在刷面试题，（虽然在平台投的简历大都没有回信-，-），也是从当初的看大家的面经一脸懵逼到现在一路走来收获了阿里和腾讯的offer。所以还是打算写一篇分享给大家。</p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>我的春招从三月初开始，一共收了了三个offer，同城艺龙（最早面的），腾讯IEG运营开发，阿里巴巴菜鸟网络Java研发。因为腾讯过了，所以期间陆续放弃了快手、携程的面试和网易、百度等大厂的笔试（比较懒，有点后悔，其实应该去面面涨涨经验的）。头条也投的比较早，当时还没准备充分其实，连最基本的堆排序都没有写出来，硬撑到三面挂了。其他也投了一些公司，不过大都没有下文了。</p><p>总的过程也比较曲折，腾讯一共面了四个部门（也就是被捞起来三次，无限秽土转生。。），共面了八次，两次一面挂，一次二面挂，最后IEG是三面技术面+一面HR通过面试。。阿里原本投的是天猫，但是在三面后流程被转到了菜鸟网络，最后是在北京现场加面了一面技术面和一面HR面，顺利通过面试。</p><p>腾讯给我的面试体验是比较好的，每面之前都会电话或者邮件预约时间，很人性化。头条是现场面，每面反馈也非常快，大概10-20min，中午还管了饭。阿里战线拉的最长，3.12号内推的，4.30号才收到意向书，每面之间都要隔1-2周吧。所以投阿里的小伙伴一定要稳住性子，毕竟有海量简历需要处理，也可以理解。</p><p>过程是曲折的，好在最后的结果是好的吧。也希望还没有理想offer的小伙伴不要着急，稳扎稳打，还有很多机会。</p><h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><p>经历了这次春招，也有了一些自己的体会，和大家分享一下吧。</p><ol><li>提早准备。金三银四是真的，三月到四月份这个时间点机会是最多的，所以一定要提早准备，多刷题、多看面经。不要抱着我还没准备好的态度，面试经验是一点点积累出来的，面的越多越知道自己的薄弱点，越自信。</li><li>《剑指offer》简直是本神书，刷五遍也不过分。再结合面经多刷一些面试经典算法题，把基本的数据结构，查找，排序算法都搞清楚，能手写，基本可以应对80%的面试。</li><li>简历很重要。多找找以前的学长学姐，对自己的简历多指导一下，一分简洁大方，重点突出的简历是很有加分的。</li><li>态度真诚。对于面试中不会的或者有些遗忘的点，可以直接和面试官说我这里不是很清楚，不要不确定的情况下硬去回答，这样反而效果不是很好。</li><li>基础最重要。总的来说，越是大厂对基础越为看重。甚至spring都没用过，只要你的算法数据结构，操作系统，计算机网络，Java基础，JVM，并发这些都能够理解的比较好，通过面试也是完全没有问题的。</li></ol><h3 id="附上腾讯和阿里面经"><a href="#附上腾讯和阿里面经" class="headerlink" title="附上腾讯和阿里面经"></a>附上腾讯和阿里面经</h3><blockquote><p>注：由于是后来回忆的，所有有一些问题记不大清楚了，只能记住个大概</p></blockquote><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><h3 id="一面-3-15（3-18-挂）"><a href="#一面-3-15（3-18-挂）" class="headerlink" title="一面 3.15（3.18 挂）"></a>一面 3.15（3.18 挂）</h3><p>聊项目（20min左右，主要针对项目架构和一些感兴趣的点深入的问）<br>TCP三次握手，四次挥手<br>知道哪些树的结构，分别介绍一下<br>算法题，给一个数组构造二叉排序树，二叉树的层次遍历，时间复杂度，空间复杂度。</p><h3 id="一面-（3-20-被腾讯音乐捞起来）"><a href="#一面-（3-20-被腾讯音乐捞起来）" class="headerlink" title="一面 （3.20 被腾讯音乐捞起来）"></a>一面 （3.20 被腾讯音乐捞起来）</h3><p>开头：能实习吗？什么时候能，<br>TCP三次握手<br>TIME_WAIT发生在什么时候<br>select/epoll了解么（不会，那跳过吧）<br>说一下进程间通信吧<br>说一下进程调度<br>哈希表了解吗，说一下<br>说一下快排<br>说一下归并排序<br>智力题：100个硬币，有一个坏的，怎么快速找到，时间复杂度<br>redis介绍一下，为什么速度快? 单线程如何保证高并发？<br>rabbitmq介绍一下，了解哪些消息队列产品，为什么用rabbitmq<br>平时课余时间都做些什么，怎么提高自己的技能？</p><h3 id="一面PCG无线运营"><a href="#一面PCG无线运营" class="headerlink" title="一面PCG无线运营"></a>一面PCG无线运营</h3><p>真的好基础<br>常见的算法</p><h3 id="二面-3-25-挂了"><a href="#二面-3-25-挂了" class="headerlink" title="二面 3.25 挂了"></a>二面 3.25 挂了</h3><p>说一下Mysql结构。。？？？怎么存储的<br>Mysql引擎有了解么，介绍一下<br>Mysql主从复制过程<br>事务特性<br>Mysql怎么实现持久性，高可用<br>OSI三层模型<br>网络层协议<br>TCP和UDP的区别<br>HTTP说一下，HTTP请求头请求行，有哪些状态，请求头有哪些，HTTP方法有哪些<br>linux，查看系统状态的命令，查看磁盘的状态？<br>redis介绍一下，redis常见数据结构，zset怎么实现的<br>redis高可用怎么实现的，高可用怎么实现，集群怎么实现，主从复制怎么实现<br>hadoop了解哪些，hdfs架构说一下，怎么实现高可用<br>hadoop中的nameserver都存储了哪些东西？文件结构是怎么样的？（一脸懵逼）<br>啊，redis和hadoop还不如不写我擦，被虐的好惨啊！！！</p><h3 id="腾讯一面-3-29"><a href="#腾讯一面-3-29" class="headerlink" title="腾讯一面 3.29"></a>腾讯一面 3.29</h3><p>基础知识，基本就是围绕网络，数据库，那些，都答腻了。。。<br>介绍一个最熟悉的项目<br>自己实现过哪些数据结构，快排和归并排序的时间复杂度，空间复杂度<br>Java 的 volatile有什么作用，怎么实现的<br>垃圾回收，内存模型<br>题目一道，两数之和，双指针</p><h3 id="腾讯二面-4-1"><a href="#腾讯二面-4-1" class="headerlink" title="腾讯二面 4.1"></a>腾讯二面 4.1</h3><p>自我介绍<br>项目情况，哪些是自己实现的，项目细节 10min左右<br>用过python和go么（答用过py，主要是java技术栈），就没继续问了<br>家庭情况，自己以后的规划<br>介绍了部门情况，问IaaS Paas知道吗<br>知道SQL注入么<br>项目对安全有什么考量，怎么增加项目的安全性<br>项目部署在哪里，用过linux么<br>说一下知道的linux命令吧，怎么查看系统负载? 端口占用？<br>shell编程会吗？<br>自己的优点有哪些</p><h3 id="腾讯三面-4-1"><a href="#腾讯三面-4-1" class="headerlink" title="腾讯三面 4.1"></a>腾讯三面 4.1</h3><p>家庭情况<br>实习时间，自己未来的规划<br>项目情况，项目整体架构，针对性的提问 10min左右<br>用过python和go么，python用过哪些库<br>Java内存模型<br>Java并发，怎么实现多线程<br>Full GC<br>多线程并发问题，怎么解决<br>Java并发控制，锁机制，怎么实现的<br>说一下乐观锁<br>Mybatis和Hibenate的区别，为什么用Mybatis<br>Mysql的并发量？锁是怎么加的？<br>RabbitMQ怎么用的</p><h3 id="HR面-4-1晚"><a href="#HR面-4-1晚" class="headerlink" title="HR面 4.1晚"></a>HR面 4.1晚</h3><p>家庭情况<br>未来的职业规划<br>为什么考研？<br>知道自己的部门吗，有什么看法？<br>什么时候能入职？</p><h3 id="阿里巴巴"><a href="#阿里巴巴" class="headerlink" title="阿里巴巴"></a>阿里巴巴</h3><h3 id="一面-3-14"><a href="#一面-3-14" class="headerlink" title="一面 3.14"></a>一面 3.14</h3><p>自我介绍<br>项目劈里啪啦，主要针对项目里使用的技术，问了大约二十多分钟<br>知道哪些树的结构，树、二叉树、平衡二叉树的应用<br>知道哪些集合类，线程安全的呢，concurrentHashMap原理<br>看过哪些jdk源码，平时都怎么学习？<br>springMVC原理，Spring AOP 实现原理<br>聊聊毕设 分布式存储相关 优化策略<br>负载均衡策略有哪些<br>数据库分表策略，分别都对应哪些场景<br>秒杀系统里怎么做的流量控制，QPS 3000，那么 6000+的请求来了怎么办<br>设计一个分布式存储系统考虑哪些<br>设计一个分布式架构怎么设计（负载均衡，缓存，一致性等等）<br>觉得自己有什么缺点<br>觉得自己有什么优点<br>有什么要问我的吗<br>总体来说主要问项目，和针对在校的情况进行一些有针对的提问，问的基础并不多，可以定义为简历评估面试。</p><h3 id="二面-3-16"><a href="#二面-3-16" class="headerlink" title="二面 3.16"></a>二面 3.16</h3><p>自我介绍，夹杂各种学校的事情<br>怼项目，设计，担任的角色<br>hashmap，对象可以当key吗，有什么注意的地方，线程安全吗，有什么线程安全的map<br>equals和hashcode有什么关系<br>gc了解吗，垃圾回收算法，策略<br>一个线程等待四个线程，怎么做<br>BloackingQueue有哪些，介绍一下<br>线程池策略，10个核心线程数，再来一个，怎么办<br>Synchronized的作用域，修饰实例方法和静态方法有什么区别<br>数据库事务隔离级别，分别会产生哪些问题<br>IO模型有哪些，答阻塞和非阻塞，感觉好像被鄙视<br>在rocketmq社区都做哪些事情<br>平时怎么学习<br>在技术上做的最自豪的一件事<br>有什么想问我的吗</p><h3 id="在线编程测验-3-24"><a href="#在线编程测验-3-24" class="headerlink" title="在线编程测验 3.24"></a>在线编程测验 3.24</h3><p>二叉树的层次遍历<br>5个线程分别计算一个数组的和，主线程汇总结果。<br>两道都A了，面试官说可以，今天先这样</p><h3 id="三面-4-3"><a href="#三面-4-3" class="headerlink" title="三面 4.3"></a>三面 4.3</h3><p>晚上9.30了都，刚做完笔试，脑袋懵呢还，接到电话。<br>项目介绍，分别介绍，怎么优化，主要针对项目用的技术问，大概15min左右，基础问的不多<br>select和epoll区别，自己用过么<br>socket代码怎么写，你用的哪种，服务器端和客户端怎么写的<br>数据库隔离级别，分别会出现什么问题<br>垃圾回收知道吗，虚拟机什么时候会full gc<br>二分排序知道么（二分排序？？？我一脸懵逼，后来发现好像意思是二路归并排序。。）<br>算法：统计大写字母出现顺序，并且排序</p><p>之后就是漫长的等待，大概等了三个周。。。</p><h3 id="四面-北京现场面-4-20"><a href="#四面-北京现场面-4-20" class="headerlink" title="四面 北京现场面 4.20"></a>四面 北京现场面 4.20</h3><p>自我介绍<br>问实验室的项目（大概有20min左右，也是分别问了项目架构和一些细节）<br>socket怎么写的，用的什么模式，NIO知道么，是阻塞的还是非阻塞的，同步的还是异步的，怎么实现。<br>rabbitmq介绍一下，为什么用。有哪些模式，你用了哪些？<br>设计模式知道吗，介绍一下，有哪些应用?<br>数据库熟悉吗？熟悉哪个？介绍一下（说了Mysql InnoDB引擎的一些特点），有什么好处<br>为什么需要事务? 解决了哪些问题?<br>MVCC了解么，说一下，解决了什么问题。版本号改成时间戳可以吗?<br>sql优化有了解么，说说一些需要主要的地方。sql执行慢怎么办？<br>web项目中中文乱码怎么解决的<br>spring介绍一下，spring ioc有什么好处，怎么解耦的。spring aop原理<br>类加载机制介绍一下，有两个同名的类怎么加载（能编译无法运行）<br>最后一个问题，浏览器输入url到页面显示发生了什么</p><h3 id="五面-hr面-4-20"><a href="#五面-hr面-4-20" class="headerlink" title="五面 hr面 4.20"></a>五面 hr面 4.20</h3><p>自我介绍<br>我说了我的名字，然后开始聊关于改名起名的事23333<br>大学学生会活动，一些活动细节<br>家庭情况<br>为什么考研<br>说说做过最极端的事<br>职业规划，为什么想来阿里<br>说说自己的优点<br>说说自己的缺点<br>问问题，什么时候能出结果？答 最早五一之前<br>总体聊的挺开心的</p>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 菜鸟+腾讯 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>腾讯+蜂巢+头条（知乎引入）</title>
      <link href="/2019/05/15/%E8%85%BE%E8%AE%AF+%E8%9C%82%E5%B7%A2+%E5%A4%B4%E6%9D%A1%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/05/15/%E8%85%BE%E8%AE%AF+%E8%9C%82%E5%B7%A2+%E5%A4%B4%E6%9D%A1%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>1、本文没有公众号和博客推广，请放心</p><p>2、Java后台开发的经验，其他岗位没有借鉴意义</p><p>3、纯发经验攒人品，不装不宣传，有问题留言大家一起讨论，互帮互助！！</p><p>4、个人学习方法，并不一定适合每个人。不喜欢看视频学习的就不用继续往下看了。</p><p>5、 由于读研都是自己挤时间的，过程不表，实验室的内容就没叙述了。</p><h3 id="一面（电话）（50分钟）面的CSIG下面的腾讯云，技术栈是Java，不过几乎不咋问Java。"><a href="#一面（电话）（50分钟）面的CSIG下面的腾讯云，技术栈是Java，不过几乎不咋问Java。" class="headerlink" title="一面（电话）（50分钟）面的CSIG下面的腾讯云，技术栈是Java，不过几乎不咋问Java。"></a>一面（电话）（50分钟）面的CSIG下面的腾讯云，技术栈是Java，不过几乎不咋问Java。</h3><ol><li>算法题：六七道，都是剑指offer难度</li><li>半小时项目介绍 &amp; 问答</li><li>分布式相关：rpc原理、微服务架构</li><li>海量数据问题：套路题</li><li>计网：传输层、网络层（必须要非常熟，ping的原理，tcp的三次握手、四次挥手、拥塞控制。UDP的不可靠、一对一、一对多）</li><li>操作系统：虚拟内存、段式、页式、进程调度算法</li><li>数据一致性： 分布式数据一致性、缓存数据一致性</li><li>Java相关：线程池、HashMap、CopyOnWriteArrayList</li><li>Redis相关：复制原理、持久化原理</li><li>杂谈：最近看什么书，实习地点。</li></ol><h3 id="二面（85分钟）"><a href="#二面（85分钟）" class="headerlink" title="二面（85分钟）"></a>二面（85分钟）</h3><ol><li>算法题：最长不重复字串</li><li>半小时钟项目介绍 &amp; 问答</li><li>操作系统：Linux的namespace（不会）、进程线程、线程通信方式、进程通信方式</li><li>计算机网络：传输层和网络层，因为我项目做了链路层，也讲了一下。</li><li>Java相关： 线程池</li><li>数据库相关： 一条连表查询语句。数据库索引原理</li><li>海量数据问题： 套路题</li><li>杂谈：介绍了部门业务</li></ol><h3 id="三面（电话）-（20分钟）"><a href="#三面（电话）-（20分钟）" class="headerlink" title="三面（电话） （20分钟）"></a>三面（电话） （20分钟）</h3><p>\1. 应该是大老板面试了，问的都很哲学：技术背景、学习方法、项目介绍<br>\2. 问了一些简单技术问题。主要考察逻辑表达和整体的素质。<br>\2. 杂谈：介绍了部门业务</p><h3 id="hr（电话）（15分钟）"><a href="#hr（电话）（15分钟）" class="headerlink" title="hr（电话）（15分钟）"></a>hr（电话）（15分钟）</h3><ol><li>家庭情况</li><li>面腾讯原因，还有面其他公司么</li><li>兴趣爱好</li><li>业务介绍</li><li>口头offer</li></ol><p>百度是去年找日常实习的面经，面了两个部门，整理了一下</p><h3 id="信息中心"><a href="#信息中心" class="headerlink" title="信息中心"></a>信息中心</h3><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ol><li>算法：字符串反转 、 倒着打印链表（为什么用递归比用栈差？） 、 单例模式</li><li>线程start 、 run方法区别</li><li>可以不通过构造函数创建对象吗？ object.clone() 反序列化</li><li>volatile关键字</li><li>Spring AOP原理（cglib 和 JDK的动态代理实现有什么区别？）</li><li>重写equals方法，为什么一定要重写hashcode方法？</li><li>字符串 == 比较。输出true还是false；</li><li>看了七八个程序，然后问输出什么？</li><li>HashMap 能不能存储 null 能，放在第一个格子里？concurrentHashMap 能不能存储 null？</li><li>分布式系统设计：现在有一个方法，可以给10台服务器调用，如何统计一天内10台电脑调用的次数和?</li><li>分布式锁的设计：每天早上8：00输出前一天的业务报表发到老板邮箱。如果现在有10台服务器，如果设计这个定时任务？<br>法1：分布式锁。法2：通过外部发来一个http请求，传给ngnix，通过ngnix自动进行分配到某一台服务器上。</li></ol><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ol><li>你对哪方面知识比较自信？</li><li>HashMap初始容量多少？（16）为啥要设计初始为16？如果传入容量10会怎么样？（还是会构建16容量的）；</li><li>知道什么异常？（说几个）</li><li>http的状态码说几个。403是什么状态？</li><li>String有什么方法？</li><li>list，set集合在iterator输出的时候能删去值吗?</li><li>SimpleDateFormat是线程安全的吗?</li><li>手写左连接。</li><li>聚合函数有哪些？</li></ol><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><ol><li>算法题：数组A和数组B，求 A并B - A交B；（说了几种，好像不满意不是最优解）</li><li>算法题：矩阵搜索（说完之后问优化，没想到，提示二分搜索）；</li><li>SSM的运作流程，说说你做的项目难点。</li><li>GET POST请求，url里面的参数</li><li>说说索引，如果对每一列都建索引有什么不好？</li><li>白盒测试、黑盒测试</li><li>Linux会吗？</li></ol><h3 id="凤巢"><a href="#凤巢" class="headerlink" title="凤巢"></a>凤巢</h3><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><ol><li>算法题：手写堆排序</li><li>Spring IOC原理 AOP原理，如何利用AOP实现日志，写过吗?</li><li>Spring bean创建的方法 注解 @Service xml配置 @bean</li><li>Java反射原理？</li><li>SpringBoot 里面 <a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/profile/558124" target="_blank" rel="noopener">@bean</a> 解释一下</li><li>Java内存模型和运行时数据区</li><li>Spring 中事务@Tranctional，出现异常回滚是怎么实现的</li><li>数据库MVCC原理</li><li>乐观锁和悲观锁概念</li><li>悲观锁的实际例子。 select * from table for update …</li><li>乐观锁实际上有没有加锁？</li><li>用两个线程去操作数据库，乐观锁具体是什么实现的？演示一遍，画一画</li><li>数据库常用存储引擎，区别，锁范围。</li><li>写过单纯的非web项目的 Spring工程， 用main实现的吗？例子。</li><li>SSM 三层技术架构的总体流程</li><li><a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/profile/603379" target="_blank" rel="noopener">@component @service</a><a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/profile/1552416" target="_blank" rel="noopener">@controller</a> 三个区别</li><li>mybatis中 # 和 $ 的区别？哪个会出现SQL注入？</li><li>JVM 新生代，老年代。survival是不是在任意时刻都只有一块有对象？</li><li>JVM 垃圾收集器了解哪些？</li></ol><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><ol><li>算法题： 实现一个四则运算计算器（两个栈 + 优先级） ， 冒泡排序</li><li>输入一个网站的全过程。从计算机网络到服务器内部技术实现流程。</li><li>日常怎么学习。</li></ol><h3 id="头条面试"><a href="#头条面试" class="headerlink" title="头条面试"></a>头条面试</h3><h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><ol><li>算法题：二分搜索相关</li><li>概念题：解释 分布式、微服务、负载均衡、高可用</li><li>http是有状态还是无状态？ TCP是有状态还是无状态？</li><li>客户端禁用cookie怎么办？ 你说的实现方式安全吗？</li><li>SSL，http和https，https是有状态还是无状态？</li><li>String为什么设计成final不可变？ 是怎么实现不可变的？</li><li>自己能实现一个不可变的类吗？</li><li>equals 和 hashcode 为什么要一起重写？如果不重写hashcode会出现什么问题？</li><li>hashmap插入的时候，哈希冲突解决？ 查找的时候，哈希冲突怎么解决？</li><li>hashset是怎么实现的？ hashmap是怎么实现hashset的？</li><li>多线程：并发和并行，原子类，CAS操作</li><li>mysql的索引：B+树底层实现？B树的底层实现？为什么要用B+树而不用B树？</li><li>最左前缀匹配具体是怎么实现查找的？最左前缀匹配用了B+树的哪些特性？</li><li>（a,b,c）联合索引，为什么不能单用（b），而一定要用（a,b）？B+树是怎么实现的？</li><li>什么是幻读，不可重复读？这些概念是在事务内还是事务外？ 事务内</li><li>mysql怎么实现可重复读？设置了可重复读隔离级别底层是怎么实现的？ （MVCC）</li><li>了解MVCC吗？怎么实现的？什么是快照读？快照读能读取到最新的吗？快照读和当前读的区别？</li><li>synchronized和reentrentlock哪个效率高？</li></ol><h3 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h3><ol><li>算法：实现一个缓存队列 ，二叉树的镜像</li><li>进程和线程的区别？内存管理说一下你的了解。进程调度算法。</li><li>为啥B+树最后叶子节点需要用链表相连接？ 便于区间查找</li><li>TCP状态转换图，画一下。</li><li>操作系统I/O模型了解吗？epoll模型了解吗？</li><li>CopyOnWriteArrayList的相关特性？</li><li>ArrayList遍历的时候能删除元素吗？ 删除的时候会报什么异常?</li></ol><h3 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h3><p>\1. 算法题： （1）树的节点最大距离（2）区间覆盖 例 [1 3] [2 5] [3 6]能否覆盖[2 6]<br>\2. Linux相关命令。<br>\3. 手写SQL，join</p>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 腾讯+蜂巢+头条 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>蚂蚁金服社招+校招面试题（知乎引入）</title>
      <link href="/2019/05/15/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%E7%A4%BE%E6%8B%9B+%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/05/15/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%E7%A4%BE%E6%8B%9B+%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>年初得蚂蚁垂青（本人非985/211，蚂蚁真的不是很在乎学历！！！），有了一次社招机会，前后经历三关，受益匪浅，在此与各位朋友分享经历与心得。</p><p><strong>需要更多Java面试资料和学习干货可以关注我的专栏Java进阶架构。</strong></p><p>第一关：在线笔试</p><p>笔试题内容如下：</p><p>说明：</p><p>构建一个本地缓存，缓存的对象是用户ID以及部分用户的信息。</p><p>当从缓存中获取某个用户数据时，如果发现该用户数据上次更新时间超过30分钟，则需要更新一次该缓存。</p><p>1.需考虑多线程访问的情况。</p><p>2.请不要使用第三方类库实现。</p><p>3.可以添加适当日志。</p><p>4.可以有适当的伪代码。</p><p>补充：UserInfo结构</p><p>public class UserInfo {</p><p>private String userId;</p><p>private String userName;</p><p>private String cardNo;</p><p>//省略其它信息和getter 和setter</p><p>}</p><p>完成下面的代码</p><p>//: TODO 可自行定义需要的变量</p><p>/**</p><p>* 初始化用户信息缓存</p><p>*/</p><p>public void initUserInfoCache() {</p><p>//: TODO 完成此处的代码</p><p>}</p><p>/**</p><p>* 根据id从缓存中获取用户信息</p><p>*/</p><p>public UserInfo getUserInfoFromCacheById(String id) {</p><p>//: TODO 完成此处的代码</p><p>}</p><p>/**</p><p>* 根据id更新缓存用户信息</p><p>*/</p><p>public void updateUserInfoCache(String id) {</p><p>//: TODO 完成此处的代码</p><p>}</p><p>题目是让在 考虑多线程的情况下实现一个缓存，题目相对简单（经历过2016的阿里校招在线笔试，简答题难度至今 记(还)忆(是)犹(不)新(会)！！！），时间上要求宽松，24小时内答完即可。</p><p>第二关：一轮电话面试</p><p>笔试题提交完毕后，大约2天后，收到一个来自于杭州蚂蚁金服IP的固定电话，不巧当时正在另外一家单位面试，恰逢一面结束，等待二面的空隙里，没办法，接了电话果然是邀请马上进行一轮电面。内心是崩溃的…。和面试官说了暂时不方便，约了半小时后再开始，面试官很爽快的同意了。</p><p>一开始依旧是自我介绍，一面提问的问题很多，很杂，涉及面很广，着重于基础，共面了55分钟左右。事后回忆问题如下：</p><p>1.jvm内存管理和分配</p><p>2.Redis</p><p>3.数据库乐观锁</p><p>3.currenthashmap的缺点</p><p>4.数据库并发</p><p>5.dubbo的调用模式，序列化</p><p>6.事务的最大级别，跨库？跨表？</p><p>7.dubbo上游100万，下游10万，如何处理</p><p>8.用户一次请求访问web的详细过程（从浏览器到web服务器经历详细过程）</p><p>9.spring的bean的周期</p><p>10.详细说下参与的项目的架构</p><p>11.hashmap 触发红黑树</p><p>12.MySQL支持的跨库事务</p><p>…</p><p>第三关：二轮电话面试</p><p>距离一面过了约一周，二面姗姗来迟。与一面的Java基础相比，二面更偏重于提问 经历的项目的架构，以及使用的框架的底层原理。（突破了会用的范围，理解框架的底层实现原理很重要，但这个很容易忽略!）。内心忐忑的聊了45分钟左右，结束了二面。</p><p>事后回忆二面问题如下：</p><p>1.说一说你最近参与的印象最深的项目，项目的架构，用到哪些技术</p><p>2.说一说spring容器的实现方式</p><p>3.说一说redis缓存应用场景</p><p>4.说一说eletasic-job与其他job定时任务的区别，以及它的优点是什么</p><p>…</p><p>附框架学习图：</p><p><img src="https://upload-images.jianshu.io/upload_images/6284737-da18a99fe699a9fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>总结：蚂蚁还是很看重基础和对框架的原理的理解程度的，说白了，对使用的技术，要知其然也知其所以然。无论是框架还是JavaAPI，底层的研究理解永远不能停。 大道至简，知易行难。</p><p>欢迎点赞，让更多人看到<br><strong>面试内容如下：</strong></p><h3 id="一、-电面："><a href="#一、-电面：" class="headerlink" title="一、 电面："></a><strong>一、 电面：</strong></h3><p>1.自我介绍<br>2.项目情况：</p><p>（1.）对你来说影响最大的一个项目（该面试中有关项目问题都针对该项目展开）？<br>(2.)为什么会想做这个项目？这个项目的ideal是谁提出来的？<br>(3.)项目中如何实现的大数据的传输和存储<br>(4.)项目中哪一部分最难攻克？如何攻克？</p><p><strong>3.基础知识考察：</strong></p><p>(1.)模块化的好处<br>(2.)Htttp协议<br>(3.)hashmap和concurrenthashmap区别及两者的优缺点<br>(4.)对MySQL的了解，和oracle的区别<br>(5.)对设计模式的看法和认知<br>(6.)如何实现分布式缓存<br>(7.)多线程如何避免死锁<br>(8.)关于树的算法题-二叉树的锯齿形层次遍历<br>(9.)Java的垃圾回收机制<br>(10.)对Runtime的了解<br>(11.)有哪些设计模式</p><ul><li>电面过程中非常注重基础知识的考察，面试前务必对基础知识内容进行复习和梳理。基础知识考察的内容一般会围绕项目内容进行展开，在前期对项目介绍进行准备时需适当换位，思考面试官的提问逻辑，避免给自己设下陷阱。</li></ul><h3 id="二、-现场面："><a href="#二、-现场面：" class="headerlink" title="二、 现场面："></a><strong>二、 现场面：</strong></h3><p><strong>1.背景了解：</strong></p><p>(1.)为什么要选择编程这条路<br>(2.)何时开始编程<br>(3.)如何进行自学<br>(4.)阅读过那些书籍</p><p><strong>2.项目考察</strong></p><p>(1.)项目运行过程中成员是否曾就某一点发生争执？作为Leader你是如何解决的？具体事例？<br>(2.)项目最终实现效果<br>(3.)项目具体部分使用的设计模式并简述选择理由<br>(4.)项目有何需改进之处并初拟改进方案<br>(5.)第一个项目：<br>(6.)第二个项目：</p><p><strong>3.基础知识考察：</strong></p><p>(1.)数据库的范式<br>(2.)JVM内存模型及调优<br>(3.)浏览器的缓存机制<br>(4.)如何解决高并发问题？是否进行过相应程序的编写？</p><p><strong>4.LintCode 算法题 - 最小子串覆盖。</strong></p><p><strong>5.想问的问题</strong></p><p>技术面中项目占了相当一部分时间，项目中从技术到个人团队领导能力，从完成执行能力到思想灵活度，都是面试官希望得到的信息。因此，必须对自己的项目多方面展开准备，项目回顾的过程中需不断思考改进方案和具体措施。</p><p>算法题部分由于之前练习时做过且在 <a href="https://link.zhihu.com/?target=http%3A//www.jiuzhang.com/solution" target="_blank" rel="noopener">www.jiuzhang.com/solution</a> 上研究过参考答案，此次应对较为轻松，面试官反应较好。在算法题考查过程中，正确率和代码效率都是面试官关注的重点，因此在Lintcode上刷题时必须强调每一个细节的改进，不能仅安于正确。上述参考网站中的标准答案工业风较强，适合实际工作，建议在刷题过程中充分利用。此外，面试前做两道算法题练手可使面试时写算法更为娴熟，如时间富裕可尝试。</p><h3 id="三、-HR面："><a href="#三、-HR面：" class="headerlink" title="三、 HR面："></a><strong>三、 HR面：</strong></h3><p>1.业余爱好<br>2.为什么不参加竞赛？<br>3.你觉得你在项目运行过程中作为组长是否最大限度发挥了组员的优势？具体事例？<br>4.如何看待阿里在大数据方面的投入？对阿里的发展有什么建议？对蚂蚁金服的发展有什么看法？<br>5.职业规划，今后想发展的工作方向<br>6.家乡在哪里，是否愿意长期在杭州发展？<br>7.薪酬问题及入职情况</p><ul><li>适当藏拙很重要，因为作为面试者，我们很难判断什么不足对公司来说是无法容忍的，如果临场随性发挥，就容易出现语言漏洞，从而被作为切入点暴露自身缺陷。因此，面试前要仔细准备各种问题，对语言进行推敲，尽量将话题引向有利于自己的方向。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><p>觉得收获的话可以点个关注收藏转发一波喔，谢谢大佬们支持。我特意整理了一下，有很多问题不是靠几句话能讲清楚，所以干脆录制了一些视频，用来回答这些面试题。很多问题其实答案很简单，但是背后的思考和逻辑不简单，要做到知其然还要知其所以然。想获取这些视频的可以私聊我，里有阿里大牛，另外有各种Java分布式、JVM、多线程等技术视频免费分享给大家。</p>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蚂蚁金服面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>多线程实际应用</title>
      <link href="/2019/05/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2019/05/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      <content type="html"><![CDATA[<h3 id="一、数据库数据修复问题"><a href="#一、数据库数据修复问题" class="headerlink" title="一、数据库数据修复问题"></a>一、数据库数据修复问题</h3><p>由于历史遗留问题，现在地址需要统一规划，以前数据库vem_net_type表中有三个字段，province,city,county，分别代表省市区，现在数据库vem_net_type表新增了三个字段，provinceCode,cityCode,countyCode，分别代表省市区编码，任务是通过HTTP接口，把新增的三个字段值更新。（数据库数据大概有30万左右）</p><ol><li><p>方案一：脑袋里面第一反应，分页从数据库读取，然后循环，调用HTTP接口，赋值，更新</p><p>优化方案：把循环调用HTTP接口，改成一次性把所有数据查询出来，然后拼装成一个map，更新丢到线程池中，提高速度。</p><p><img src="/Users/wlnie/Library/Application Support/typora-user-images/image-20190515151056594.png" alt="image-20190515151056594"></p></li><li><p>方案二：启用两个线程，一个线程负责向队列扔数据，一个线程负责从队列中读取数据，做到边读边取。</p><p>具体：一个线程以1000为单位进行分页查询之后，把数据丢到队列中，另外一个线程，不断从队列中poll，poll到数据之后，调用HTTP接口，赋值，更新。</p></li></ol><p><img src="/Users/wlnie/Library/Application Support/typora-user-images/image-20190515151247725.png" alt="image-20190515151247725"></p><p><img src="/Users/wlnie/Library/Application Support/typora-user-images/image-20190515151313504.png" alt="image-20190515151313504"></p><p><img src="/Users/wlnie/Library/Application Support/typora-user-images/image-20190515151340475.png" alt="image-20190515151340475"></p>]]></content>
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程实际应用 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dubbo理解</title>
      <link href="/2019/05/14/dubbo%E7%90%86%E8%A7%A3/"/>
      <url>/2019/05/14/dubbo%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><img src="http://dubbo.apache.org/img/architecture.png" alt="架构图"></p><p>dubbo存在的意义：</p><ol><li>维护各个节点的URL。</li><li>监控各个节点的状态（性能，响应时间，访问量等）。</li></ol>]]></content>
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/05/09/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/05/09/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<p><img src="/Users/wlnie/Library/Application Support/typora-user-images/image-20190509163746468.png" alt="image-20190509163746468"></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>zookeeper学习笔记-1</title>
      <link href="/2019/02/14/zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/14/zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><strong>实际应用（典型）</strong>：</p><ol><li>Master-slave 选举（创建节点，只能有一个成功），2ddd14e24bc0275a1a49b7a69ac3684eebbaefc8</li><li>分布式锁（创建节点，只能有一个是成功），7ce84dc41a62a299d2631aa1d0de7f19d86f3926</li></ol>]]></content>
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019学习计划</title>
      <link href="/2019/02/13/2019%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
      <url>/2019/02/13/2019%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      <content type="html"><![CDATA[<p>​    2018学习总结，记忆较为深刻的学习有：1. hashmap原理，2. 消息队列RocketMq。未学习的知识点依然很多，2019年，列下学习计划，不断地总结，不断地反思。</p><p>​    现在是2月份，今天给自己定个目标，希望自己可以跟着目标走，不迷茫，每天活的充实。</p><h3 id="目标："><a href="#目标：" class="headerlink" title="目标："></a>目标：</h3><ol><li>zookeeper（思想、理论）</li><li>缓存相关（思想、理论）</li><li>多线程</li><li>JVM</li><li>设计模式</li><li>分布式相关</li></ol><p>看了丰兄分享的视频，整体上看还是很不错的，所以目前学习计划有所改变，下面指定学习计划，整体上围绕着上面的目标来。</p><p>第一章，maven，git，Jenkins 大致了解，不需很深入，因为全部都很熟，而且一直在用，但是视频必须看完。</p><p>第二章，spring mybatis源码留到最后看，加深理解。</p><p>第三章，分布式专题，跟着视频走，自己必须有自己的理解，因为版本的迭代，有些方案和方法可能已经被淘汰。</p><p>第四章，微服务，在分布式专题和性能优化以及多线程之后学习。</p><p>第五章，性能优化，紧跟着分布式专题进行学习。</p><p>后面几章在上面👆这些计划完成之后，在继续学习，和巩固。</p><p>目前规划排序：</p><ol><li>maven、git、Jenkins 视频学习（2019-03-01 - 2019-03-08）</li><li>分布式专题 视频学习（2019-03-01 - 待定）</li><li>性能优化 视频学习</li><li>多线程 自我学习</li></ol><p>学习往往赶不上变化，在学习的过程中，发现，基础很重要，所以打算把计算机基础过一遍，数据结构=&gt;计算机组成=&gt;计算机系统=&gt;计算机网络，后面有三块需要认真阅读，</p><ol><li>JVM（深入理解虚拟机）</li><li>多线程</li><li>spring源码</li><li>rocket源码</li><li>netty源码</li></ol><p>计算机组成和计算机系统，看了下目录，都比较偏硬件，所以先看计算机网络，如果后面JVM，多线程等知识需要计算机相关的原理，在一个一个去看，所以当前的学习顺序是：</p><ol><li>数据结构（已经看完一遍）</li><li>计算机网络（doing）</li><li>JVM原理</li><li>多线程</li><li>spring源码</li></ol>]]></content>
      
      <categories>
          
          <category> 学习计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019学习计划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMq理解</title>
      <link href="/2018/12/06/RocketMq%E7%90%86%E8%A7%A3/"/>
      <url>/2018/12/06/RocketMq%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>producer，nameServer，broker，consumer</p><p>nameServer无状态，可以集群，互相不影响，独立。</p><p>broker是以group为单位提供服务。</p><p>b1 b2 b3 的group都是order-create-group，那么b1 b2 b3构成一个单位，默认每个broker都有4个队列，那就是12个队列，consumer交叉式连接，达到负载均衡的目的。b1 b2 b3是三个主，可以有自己的从。</p><p>最合适的方案：多master多slave（同步复制SYNC_MASTER），异步刷盘（ASYNC_FLUSH）</p><p>其中最主要的两个，事务消息，顺序消息？</p><p>事务消息：TODO</p>]]></content>
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMq名词介绍</title>
      <link href="/2018/11/06/RocketMq%E5%90%8D%E7%A7%B0%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/11/06/RocketMq%E5%90%8D%E7%A7%B0%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h3 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h3><hr><h5 id="Name-Server"><a href="#Name-Server" class="headerlink" title="Name Server"></a>Name Server</h5><p><em>介绍：类始于zookeeper在dubbo服务中的作用，作为寻址服务，用于把Broker的路由信息做聚合，客户端依靠NameServer去获取对应topic的路由信息，从而决定对哪些Broker做连接</em></p><ul><li>Name Server之间采取share-nothing的设计，互不通信。</li><li>对于一个Name Server集群列表，客户端连接Name Server的时候，只会选择随机连接一个节点，以做到负载均衡。</li><li>Name Server的所有状态都从Broker上报而来，本身不存储任何状态，不会影响和Broker的通讯，简而言之：Name Server如果挂了，不会影响客户端和正常的Broker之间的通讯，但是在挂掉之后新增的Broker客户端是感知不到的。</li></ul><h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><p><em>介绍：处理消息存储，转发等处理的服务器</em></p><ul><li>Broker是以group分开，每个group只允许一个master，若干个slave</li><li>只有master才能进行写入操作，slave不允许</li><li>slave从master中同步数据。同步策略取决于master的配置，可以采用同步双写，异步复制两种。</li><li>客户端消费可以从master和slave消费。在默认情况下，消费者都从master消费，在master挂掉后，客户端由于从NameServer中感知到Broker挂机，就会从slave消费。</li><li>Broker向所有的NameServer结点建立长连接，注册topic信息。</li></ul><h4 id="PushConsumer"><a href="#PushConsumer" class="headerlink" title="PushConsumer"></a>PushConsumer</h4><p><em>推送模式（RocketMq使用的是长轮询）的消费者。消息能及时被消费，使用简单。</em></p><h4 id="PullConsumer"><a href="#PullConsumer" class="headerlink" title="PullConsumer"></a>PullConsumer</h4><p><em>拉取模式的消费者，应用主动控制拉取的时机，怎么拉取，怎么消费等。主动权更高。</em></p><h4 id="Producer-Group"><a href="#Producer-Group" class="headerlink" title="Producer Group"></a>Producer Group</h4><p><em>标识发送同一类消息的生产者，通常发送逻辑一致。发送普通消息的时候，仅标识使用，并无特别用处。  若事务消息，如果某天发送某  条消息的producer-A宕机，是的事务消息一直处于PREPARED状态并超时，则broker会会查同一个group的其他producer-B，确定这条消息应该commit还是rollback。（已阉割此功能）</em></p><h4 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h4><p><em>标识一类消费者的集合名称，这类消费者通常消费一类消息，且消费逻辑一致。同一个Consumer Group下的各个实例将共同消费topic的消息，起到负载均衡的作用。</em></p><p><em>消费进度以Consumer Group为粒度管理，不同Consumer Group之间消费进度彼此不受影响，即消息A被Consumer Group1消费过，也会在给Consumer Group2消费。</em></p><p><em>注：RocketMQ要求同一个Consumer Group的消费者必须要拥有相同的注册信息，即必须要一样的topic(并且tag也一样)。</em></p><h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><p><em>标识一类消息的逻辑名字，消息的逻辑管理单位。无论消息生成还是消费，都需要指定Topic。</em></p><h4 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h4><p><em>比topic粒度更细，同一个topic的消息虽然逻辑管理一样，但是消费topic的时候，如果订阅的时候指定的是tagA，那么tagB的消息将不会投递，也就不会消费。</em></p><h4 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h4><p><em>简称Queue或Q，一个Topic将有若干个Q，若Topic同时创建在不同的Broker，则不同的Broker上都有若干Q，消息将物理的存储落在不同Broker结点上，具有水平扩展的能力。</em></p><p><em>无论生产者还是消费者，实际的生成和消费都是针对Q级别。例如producer发送消息的时候，会预先选择（默认轮询）好该Topic下面的某一条Q发送；Consumer消费的时候也会负载均衡地分配若干个Q，只拉取对应Q的消息。</em></p><p><em>每一条message queue均对应一个文件，这个文件存储了实际消息的索引信息。并且即使文件被删除，也能通过实际纯粹的消息文件（commit log）恢复回来。</em></p><h4 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a>Offset</h4><p><em>偏移量，可以认为一条逻辑的message queue是无限长的数组。一条消息进来下标就会涨1。下标就是offset。</em></p><p><em>一条message queue中的max offset表示消息的最大offset。max offset= 最新offset+1。</em></p><p><em>min offset 则标识现存在的最小offset。</em></p><p><em>消息存储一段时间后，消息会被物理地从磁盘删除，message queue的min offset也就对应增长。这意味着比min offset要小的那些消息已经不在broker上，无法被消费。</em></p><h4 id="Consumer-Offset"><a href="#Consumer-Offset" class="headerlink" title="Consumer Offset"></a>Consumer Offset</h4><p><em>用于标记Consumer group在一条逻辑Message Queue上，消息消费到哪里了。</em></p><ul><li><em>注：从源码上看，这个数值是最新消费的那条消息的offset+1，所以实际上这个值存储的是【下次拉取的话，从哪里开始拉取的offset】。</em></li></ul><p><em>消费者拉取消息的时候需要指定offset，broker不主动推送消息，而是接受到请求的时候把存储的对应offset的消息返回给客户端。这个offset在成功消费后会更新到内存，并定时持久化。在集群消费模式下，会同步持久化到broker。在广播模式下，会持久化到本地文件。</em></p><p><em>实例重启的时候会获取持久化的Consumer offset，用以决定从哪里开始消费。</em></p><h4 id="集群消费"><a href="#集群消费" class="headerlink" title="集群消费"></a>集群消费</h4><p><em>消费者的一种消费模式。一个Consumer Group中的各个Consumer实例分摊去消费消息，即一条消息只会投递到一个Consumer group下面的一个实例。</em></p><p><em>实际上，每个Consumer是平均分摊Message Queue的去做拉取消费。例如某个Topic有3条Q，其中一个Consumer Group有3个实例（可能是3个进程或者3台机器），那么每个实例只消费其中的一条Q。</em></p><p><em>而由Producer发送消息的时候是轮询所有的Q，所以消息就会平均的散落在不同的Q上，可以认为Q上的消息是平均的。那么实例也就平均地消费消息了。</em></p><p><em>这种模式下，消费进度的存储会持久化到Broker。</em></p><h4 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h4><p><em>消费者的一种消费模式。消息将对一个Consumer Group的各个实例都投递一遍。</em></p><p><em>实际上，是一个消费组下的每个消费者实例都获取到了topic下面的每个Message Queue去拉取消息。所以消息会投递到每个消费者实例。</em></p><p><em>这种模式下，消费进度会存储持久化到实例本地。</em></p><h4 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h4><p><em>消费消息的顺序要同发送消息的顺序一致。由于Consumer消费消息的时候是针对Message Queue顺序拉取并开始消费，且一条Message Queue只会给一个消费者（集群模式下），所以能够保证同一个消费者对于Q上消息的消费是顺序的开始消费（不一定顺序消费完成，因为消费可能并行）。</em></p><p><em>在RocketMQ中，顺序消费主要指的都是Queue级别的局部顺序。这一类消息为满足顺序性，必须Producer单线程顺序发送，且发送到同一个队列，这样Consumer就可以按照Producer发送的顺序去消费消息。</em></p><p><em>生产者发送的时候可以用MessageQueueSelector为某一批消息选择同一个Queue，则这一批消息的消费将是顺序消息（并由同一个Consumer完成消费）。或者Message Queue的数量只有1，但这样消费的实例只能有一个，多出来的实例都会空跑。</em></p><h4 id="普通顺序消息"><a href="#普通顺序消息" class="headerlink" title="普通顺序消息"></a>普通顺序消息</h4><p><em>顺序消息的一种，正常情况下可以保证完全的顺序消息，但是一旦发生异常，Broker宕机或重启，由于队列总数发生变化，消费者会触发负载均衡，而默认地负载均衡算法采取哈希取模平均，这样负载均衡分配到定位的队列会发生变化，使得队列可能分配到别的实例上，则会短暂性的出现消息顺序不一致。</em></p><p><em>如果业务能容忍在集群异常情况下（某个Broker宕机或重启），消息短暂的乱序，使用普通顺序方式最合适。</em></p><h4 id="严格顺序消息"><a href="#严格顺序消息" class="headerlink" title="严格顺序消息"></a>严格顺序消息</h4><p><em>顺序消息的一种，无论正常异常情况都能保证顺序，但是牺牲了分布式failover（失效备援）特性，即Broker集群中只要有一台机器不可用，则整个集群都不可用，服务可用性大大降低。</em></p><p><em>如果服务器部署为同步双写模式，此缺陷可通过备机自动切换为主避免，不过依然会存在几分钟的服务不可用。</em></p>]]></content>
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018学习计划</title>
      <link href="/2018/06/02/2018%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
      <url>/2018/06/02/2018%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      <content type="html"><![CDATA[<h2 id="2018学习计划"><a href="#2018学习计划" class="headerlink" title="2018学习计划"></a>2018学习计划</h2><p>​    2017年学习的一年，准确的说是半年吧，看了很多书，也做了很多笔记，后面姐姐来了之后，学习就落下了，今年一年已经快过去一小半了，是时候继续学习了，战斗吧，骚年。进入新公司，投入百分之120的努力，学习投入百分之100的努力，希望每天都可以看到自己的成长和收获。</p><p>​    学习不能囫囵吞枣，还是要一个一个来，逐个击破，切记不能急躁，要稳住，稳住，不然后期乏力，打不了团，上不了台面。知识点：JVM，redis，zookeeper，rocketmq，多线程，netty，Spring cloud，Java基础，设计模式，今年核心必须要掌握的知识点：</p><h5 id="RocketMq（两个月）"><a href="#RocketMq（两个月）" class="headerlink" title="RocketMq（两个月）"></a>RocketMq（两个月）</h5><blockquote><p>主要作用：</p><p>主要解决应用耦合，异步消息，流量削锋等问题。实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。</p><p>目标：</p><ol><li>做一个抢购的案例，可以做到10000人同时购买一件商品，只有1000个人可以下单，仅仅只有一个人可以购买成功。</li><li>消息的发送以及监控。</li></ol></blockquote><h5 id="Zookeeper（两个月）"><a href="#Zookeeper（两个月）" class="headerlink" title="Zookeeper（两个月）"></a>Zookeeper（两个月）</h5><blockquote><p>目标：</p><ol><li>Zookeeper 的实际场景应用。</li><li>Zookeeper 的临时节点存储信息等常用操作。</li><li>分布式锁的实现。</li></ol></blockquote><h5 id="Redis（一个月）"><a href="#Redis（一个月）" class="headerlink" title="Redis（一个月）"></a>Redis（一个月）</h5><blockquote><p>目标：</p><ol><li>不能仅限于理论知识，把技术玩到项目中去。</li><li>缓存的一些优化，处理，比如：定时同步，缓存击穿等等。</li></ol></blockquote><h5 id="JVM（两个月）"><a href="#JVM（两个月）" class="headerlink" title="JVM（两个月）"></a>JVM（两个月）</h5><blockquote><p>目标：</p><ol><li>看得懂日志，可以分析日志，当发生内存泄漏或者内存不足的时候可以定位问题。</li><li>熟练运用好jprofiler工具。</li></ol></blockquote><h5 id="多线程（两个月）"><a href="#多线程（两个月）" class="headerlink" title="多线程（两个月）"></a>多线程（两个月）</h5><blockquote><p>目标：</p><ol><li>能够明显感觉多线程带来的性能的提升。</li><li>实际运用多线程的例子，而不是理论知识。</li></ol></blockquote><h5 id="Netty（暂且仅限会用即可）"><a href="#Netty（暂且仅限会用即可）" class="headerlink" title="Netty（暂且仅限会用即可）"></a>Netty（暂且仅限会用即可）</h5><blockquote><p>目标：</p><ol><li>在现有的框架基础下，进行开发，知道各个配置的作用。</li></ol></blockquote><h5 id="Spring-Cloud（不急，等待前面这些学习完了，来玩这个）"><a href="#Spring-Cloud（不急，等待前面这些学习完了，来玩这个）" class="headerlink" title="Spring Cloud（不急，等待前面这些学习完了，来玩这个）"></a>Spring Cloud（不急，等待前面这些学习完了，来玩这个）</h5><blockquote><p>目标：</p><ol><li>根据程序员DD的博客来学习。</li></ol></blockquote><p>​    学习任何一个知识点，都应该做到，首先把这个知识点宏观上理解它的用处，然后并实践，在实践的过程中会遇到很多坑，解决问题，然后在回过头来，看源代码，理解。    </p><p>​    学习的顺序，每一个都很重要，但是还是要写下规划，第一先弄透RocketMq，这个在分布式中很重要，预计花费两个月时间学习这个，然后学习zookeeper，因为公司项目里面有用到这个，而且这个是时候学习下了，时间两个月时间学习，然后在学习缓存，提高高度，应用到实际项目中，然后在学习多线程和JVM，最后学习Spring cloud。就这么愉快的决定了，同样的问题，再次去看待，收获肯定不一样。</p>]]></content>
      
      <categories>
          
          <category> 学习计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2018学习计划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hashmap深入研究-1</title>
      <link href="/2018/04/27/hashMap%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6-1/"/>
      <url>/2018/04/27/hashMap%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6-1/</url>
      <content type="html"><![CDATA[<h4 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h4><ul><li>数据结构中有数组和链表来实现对数据的存储，但这两者基本上是两个极端。所有的数据结构都可以用这两个基本结构来构造的</li><li><strong>数组</strong>：数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；</li><li><strong>链表</strong>：链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。</li><li><strong>哈希表</strong>（(Hash table）：由数组+链表组成的。既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。实际上hashMap是一个链表散列</li></ul><hr><h4 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h4><ul><li>hashMap是一个用于存储key-value键值对的集合，每一个键值对也被叫做Entry。这些个键值对分散存储在一个数组当中，这个数组就是HaspMap的主干。</li><li>总体上看，Hashmap分为很多个数组，每一个数组里面存放着一个链表，结构图如下。</li></ul><h5 id="数据结构图形表示："><a href="#数据结构图形表示：" class="headerlink" title="数据结构图形表示："></a>数据结构图形表示：</h5><ul><li>HashMap的<strong>数组</strong>每一个元素的初始值都是Null。<blockquote><p><img src="http://upload-images.jianshu.io/upload_images/6284737-955ed6f84da5404c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote></li><li>详细的结构<blockquote><p><img src="http://upload-images.jianshu.io/upload_images/6284737-ee3a40ebee689321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><h4 id="put方法的原理："><a href="#put方法的原理：" class="headerlink" title="put方法的原理："></a>put方法的原理：</h4></li><li><p>比如调用hashMap.put(“apple”,0),插入一个key为”apple”的元素。这时候我们需要利用一个哈希函数来确定Entry的插入位置(index)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = Hash(&quot;apple&quot;)</span><br></pre></td></tr></table></figure></li><li><p>假定最后计算的index为2，那么结果如下：</p><blockquote><p><img src="http://upload-images.jianshu.io/upload_images/6284737-45f5586d614337ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>但是，因为HashMap的长度是有限的，当插入的Entry越来越多的时候，会出现index冲突的情况，比如两个值计算的index都是2，这个时候就可以利用链表来解决了<br><img src="http://upload-images.jianshu.io/upload_images/6284737-5e5613ceffe569da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>HashMap 数组的每一个元素不止包含一个Entry(键值对)对象，也包含一个链表的头结点，每一个Entry对象通过next指针指向它的下一个Entry节点(链表)，当新来的Entry映射到冲突的数组位置时，只需要插入到对应的链表即可：<br><img src="http://upload-images.jianshu.io/upload_images/6284737-84acbc1cd3522e17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>需要注意的是，新来的Entry节点插入链表时，使用的是”头插法”，这样是因为HashMap的发明者认为后插入的Entry被查找的可能性更大</li></ul></blockquote></li></ul><h4 id="Get方法的原理"><a href="#Get方法的原理" class="headerlink" title="Get方法的原理"></a>Get方法的原理</h4><ul><li><p>首先会根据输入的Key做一次Hash映射，得到对应的index：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = Hash(&quot;apple&quot;)</span><br></pre></td></tr></table></figure></li><li><p>由于刚才说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候需要顺着对应链表的头节点，一个一个向下来查找(链表)</p><blockquote><p><img src="http://upload-images.jianshu.io/upload_images/6284737-ad7cd5d1e3d73adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote></li><li>第一步，我们查看的是头节点Entry6，它的key是 banana很明显不是。</li><li>第二部，我们查看的next几点Entry1，它的key是 apple，正是结果。</li></ul><h4 id="HashMap的默认长度是16，以后每次必须是2的幂-16"><a href="#HashMap的默认长度是16，以后每次必须是2的幂-16" class="headerlink" title="HashMap的默认长度是16，以后每次必须是2的幂*16"></a>HashMap的默认长度是16，以后每次必须是2的幂*16</h4><p><img src="https://upload-images.jianshu.io/upload_images/6284737-54c921896cf6134d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>说明：</li></ul><ol><li>&amp; 按位与：只有对应的两个二进位均为1时，结果位才为1 ，否则为0。</li><li>^ 按位异或：当两对应的二进位相异时，结果为1</li><li>符号&gt;&gt;&gt;：&gt;&gt;(按位右移)，&lt;&lt;(按位左移)，&gt;&gt;&gt;(按位右移不足补0),表示无符号右移！</li></ol><ul><li>下面演示下以”book”为例的整个过程：</li></ul><ol><li>计算book的hashcode，结果为十进制的3029737，二进制是10111000111010111101001.</li><li>假定默认长度是16，Length-1是15，二进制就是1111</li><li>根据公式，做与运算，结果是1001，十进制就是9.</li><li>假定默认长度是10，Lnegth-1是9，二进制就是1001</li><li>根据公式，结果也是1001，十进制是9，换一个HashCode，比如是1011100011101011101111，计算结果依然是1001</li><li>由于舒建雄看不懂，特此加注：如果不是1111 只要出现0的，也就意味着计算的结果出现的也有0，比如 1011 结果肯定是X0XX<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5></li></ol><ul><li>当hashMap长度不为16的2的幂时候，出现冲突的几率会更大一些，甚至有些结果永远不会出现。</li><li>可以说，Hash算法最终得到的index结果，完全取决于key的HashCode值的最后几位。1111或者11111或者111111…都是16的2的幂，是为了保证算法均匀。</li></ul>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
